// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: paymentnote.sql

package generated

import (
	"context"
	"database/sql"
)

const countPaymentNotes = `-- name: CountPaymentNotes :one
SELECT COUNT(*) FROM payment_notes
WHERE
    ($1::text IS NULL OR status = $1) AND
    ($2::boolean IS NULL OR is_draft = $2) AND
    ($3::text IS NULL OR (
        note_no ILIKE '%' || $3 || '%' OR
        subject ILIKE '%' || $3 || '%' OR
        vendor_name ILIKE '%' || $3 || '%' OR
        project_name ILIKE '%' || $3 || '%'
    ))
`

type CountPaymentNotesParams struct {
	Column1 string `json:"column_1"`
	Column2 bool   `json:"column_2"`
	Column3 string `json:"column_3"`
}

func (q *Queries) CountPaymentNotes(ctx context.Context, arg CountPaymentNotesParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPaymentNotes, arg.Column1, arg.Column2, arg.Column3)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPaymentNote = `-- name: CreatePaymentNote :one
INSERT INTO payment_notes (
    user_id,
    green_note_id,
    green_note_no,
    green_note_approver,
    green_note_app_date,
    reimbursement_note_id,
    note_no,
    subject,
    date,
    department,
    vendor_code,
    vendor_name,
    project_name,
    invoice_no,
    invoice_date,
    invoice_amount,
    invoice_approved_by,
    loa_po_no,
    loa_po_amount,
    loa_po_date,
    gross_amount,
    total_additions,
    total_deductions,
    net_payable_amount,
    net_payable_round_off,
    net_payable_words,
    tds_percentage,
    tds_section,
    tds_amount,
    account_holder_name,
    bank_name,
    account_number,
    ifsc_code,
    recommendation_of_payment,
    status,
    is_draft,
    auto_created,
    created_by
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10,
    $11, $12, $13, $14, $15, $16, $17, $18, $19, $20,
    $21, $22, $23, $24, $25, $26, $27, $28, $29, $30,
    $31, $32, $33, $34, $35, $36, $37, $38
)
RETURNING id, user_id, green_note_id, green_note_no, green_note_approver, green_note_app_date, reimbursement_note_id, note_no, subject, date, department, vendor_code, vendor_name, project_name, invoice_no, invoice_date, invoice_amount, invoice_approved_by, loa_po_no, loa_po_amount, loa_po_date, gross_amount, total_additions, total_deductions, net_payable_amount, net_payable_round_off, net_payable_words, tds_percentage, tds_section, tds_amount, account_holder_name, bank_name, account_number, ifsc_code, recommendation_of_payment, status, is_draft, auto_created, created_by, hold_reason, hold_date, hold_by, utr_no, utr_date, created_at, updated_at
`

type CreatePaymentNoteParams struct {
	UserID                  int64                 `json:"user_id"`
	GreenNoteID             sql.NullString        `json:"green_note_id"`
	GreenNoteNo             sql.NullString        `json:"green_note_no"`
	GreenNoteApprover       sql.NullString        `json:"green_note_approver"`
	GreenNoteAppDate        sql.NullString        `json:"green_note_app_date"`
	ReimbursementNoteID     sql.NullInt64         `json:"reimbursement_note_id"`
	NoteNo                  string                `json:"note_no"`
	Subject                 sql.NullString        `json:"subject"`
	Date                    sql.NullTime          `json:"date"`
	Department              sql.NullString        `json:"department"`
	VendorCode              sql.NullString        `json:"vendor_code"`
	VendorName              sql.NullString        `json:"vendor_name"`
	ProjectName             sql.NullString        `json:"project_name"`
	InvoiceNo               sql.NullString        `json:"invoice_no"`
	InvoiceDate             sql.NullString        `json:"invoice_date"`
	InvoiceAmount           sql.NullString        `json:"invoice_amount"`
	InvoiceApprovedBy       sql.NullString        `json:"invoice_approved_by"`
	LoaPoNo                 sql.NullString        `json:"loa_po_no"`
	LoaPoAmount             sql.NullString        `json:"loa_po_amount"`
	LoaPoDate               sql.NullString        `json:"loa_po_date"`
	GrossAmount             string                `json:"gross_amount"`
	TotalAdditions          string                `json:"total_additions"`
	TotalDeductions         string                `json:"total_deductions"`
	NetPayableAmount        string                `json:"net_payable_amount"`
	NetPayableRoundOff      string                `json:"net_payable_round_off"`
	NetPayableWords         sql.NullString        `json:"net_payable_words"`
	TdsPercentage           sql.NullString        `json:"tds_percentage"`
	TdsSection              sql.NullString        `json:"tds_section"`
	TdsAmount               sql.NullString        `json:"tds_amount"`
	AccountHolderName       sql.NullString        `json:"account_holder_name"`
	BankName                sql.NullString        `json:"bank_name"`
	AccountNumber           sql.NullString        `json:"account_number"`
	IfscCode                sql.NullString        `json:"ifsc_code"`
	RecommendationOfPayment sql.NullString        `json:"recommendation_of_payment"`
	Status                  NullPaymentNoteStatus `json:"status"`
	IsDraft                 bool                  `json:"is_draft"`
	AutoCreated             bool                  `json:"auto_created"`
	CreatedBy               sql.NullInt64         `json:"created_by"`
}

func (q *Queries) CreatePaymentNote(ctx context.Context, arg CreatePaymentNoteParams) (PaymentNote, error) {
	row := q.db.QueryRowContext(ctx, createPaymentNote,
		arg.UserID,
		arg.GreenNoteID,
		arg.GreenNoteNo,
		arg.GreenNoteApprover,
		arg.GreenNoteAppDate,
		arg.ReimbursementNoteID,
		arg.NoteNo,
		arg.Subject,
		arg.Date,
		arg.Department,
		arg.VendorCode,
		arg.VendorName,
		arg.ProjectName,
		arg.InvoiceNo,
		arg.InvoiceDate,
		arg.InvoiceAmount,
		arg.InvoiceApprovedBy,
		arg.LoaPoNo,
		arg.LoaPoAmount,
		arg.LoaPoDate,
		arg.GrossAmount,
		arg.TotalAdditions,
		arg.TotalDeductions,
		arg.NetPayableAmount,
		arg.NetPayableRoundOff,
		arg.NetPayableWords,
		arg.TdsPercentage,
		arg.TdsSection,
		arg.TdsAmount,
		arg.AccountHolderName,
		arg.BankName,
		arg.AccountNumber,
		arg.IfscCode,
		arg.RecommendationOfPayment,
		arg.Status,
		arg.IsDraft,
		arg.AutoCreated,
		arg.CreatedBy,
	)
	var i PaymentNote
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GreenNoteID,
		&i.GreenNoteNo,
		&i.GreenNoteApprover,
		&i.GreenNoteAppDate,
		&i.ReimbursementNoteID,
		&i.NoteNo,
		&i.Subject,
		&i.Date,
		&i.Department,
		&i.VendorCode,
		&i.VendorName,
		&i.ProjectName,
		&i.InvoiceNo,
		&i.InvoiceDate,
		&i.InvoiceAmount,
		&i.InvoiceApprovedBy,
		&i.LoaPoNo,
		&i.LoaPoAmount,
		&i.LoaPoDate,
		&i.GrossAmount,
		&i.TotalAdditions,
		&i.TotalDeductions,
		&i.NetPayableAmount,
		&i.NetPayableRoundOff,
		&i.NetPayableWords,
		&i.TdsPercentage,
		&i.TdsSection,
		&i.TdsAmount,
		&i.AccountHolderName,
		&i.BankName,
		&i.AccountNumber,
		&i.IfscCode,
		&i.RecommendationOfPayment,
		&i.Status,
		&i.IsDraft,
		&i.AutoCreated,
		&i.CreatedBy,
		&i.HoldReason,
		&i.HoldDate,
		&i.HoldBy,
		&i.UtrNo,
		&i.UtrDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deletePaymentNote = `-- name: DeletePaymentNote :exec
DELETE FROM payment_notes
WHERE id = $1
`

func (q *Queries) DeletePaymentNote(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deletePaymentNote, id)
	return err
}

const deletePaymentNoteDocument = `-- name: DeletePaymentNoteDocument :exec
DELETE FROM payment_note_documents
WHERE id = $1
`

func (q *Queries) DeletePaymentNoteDocument(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deletePaymentNoteDocument, id)
	return err
}

const deletePaymentParticulars = `-- name: DeletePaymentParticulars :exec
DELETE FROM payment_note_particulars
WHERE payment_note_id = $1
`

func (q *Queries) DeletePaymentParticulars(ctx context.Context, paymentNoteID int64) error {
	_, err := q.db.ExecContext(ctx, deletePaymentParticulars, paymentNoteID)
	return err
}

const getNextPaymentNoteNumber = `-- name: GetNextPaymentNoteNumber :one
SELECT COALESCE(MAX(CAST(SUBSTRING(note_no FROM '[0-9]+$') AS INTEGER)), 0) + 1 AS next_number
FROM payment_notes
WHERE note_no LIKE $1 || '%'
`

func (q *Queries) GetNextPaymentNoteNumber(ctx context.Context, dollar_1 sql.NullString) (int32, error) {
	row := q.db.QueryRowContext(ctx, getNextPaymentNoteNumber, dollar_1)
	var next_number int32
	err := row.Scan(&next_number)
	return next_number, err
}

const getPaymentNoteByGreenNoteID = `-- name: GetPaymentNoteByGreenNoteID :one
SELECT id, user_id, green_note_id, green_note_no, green_note_approver, green_note_app_date, reimbursement_note_id, note_no, subject, date, department, vendor_code, vendor_name, project_name, invoice_no, invoice_date, invoice_amount, invoice_approved_by, loa_po_no, loa_po_amount, loa_po_date, gross_amount, total_additions, total_deductions, net_payable_amount, net_payable_round_off, net_payable_words, tds_percentage, tds_section, tds_amount, account_holder_name, bank_name, account_number, ifsc_code, recommendation_of_payment, status, is_draft, auto_created, created_by, hold_reason, hold_date, hold_by, utr_no, utr_date, created_at, updated_at FROM payment_notes
WHERE green_note_id = $1
LIMIT 1
`

func (q *Queries) GetPaymentNoteByGreenNoteID(ctx context.Context, greenNoteID sql.NullString) (PaymentNote, error) {
	row := q.db.QueryRowContext(ctx, getPaymentNoteByGreenNoteID, greenNoteID)
	var i PaymentNote
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GreenNoteID,
		&i.GreenNoteNo,
		&i.GreenNoteApprover,
		&i.GreenNoteAppDate,
		&i.ReimbursementNoteID,
		&i.NoteNo,
		&i.Subject,
		&i.Date,
		&i.Department,
		&i.VendorCode,
		&i.VendorName,
		&i.ProjectName,
		&i.InvoiceNo,
		&i.InvoiceDate,
		&i.InvoiceAmount,
		&i.InvoiceApprovedBy,
		&i.LoaPoNo,
		&i.LoaPoAmount,
		&i.LoaPoDate,
		&i.GrossAmount,
		&i.TotalAdditions,
		&i.TotalDeductions,
		&i.NetPayableAmount,
		&i.NetPayableRoundOff,
		&i.NetPayableWords,
		&i.TdsPercentage,
		&i.TdsSection,
		&i.TdsAmount,
		&i.AccountHolderName,
		&i.BankName,
		&i.AccountNumber,
		&i.IfscCode,
		&i.RecommendationOfPayment,
		&i.Status,
		&i.IsDraft,
		&i.AutoCreated,
		&i.CreatedBy,
		&i.HoldReason,
		&i.HoldDate,
		&i.HoldBy,
		&i.UtrNo,
		&i.UtrDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPaymentNoteByID = `-- name: GetPaymentNoteByID :one
SELECT id, user_id, green_note_id, green_note_no, green_note_approver, green_note_app_date, reimbursement_note_id, note_no, subject, date, department, vendor_code, vendor_name, project_name, invoice_no, invoice_date, invoice_amount, invoice_approved_by, loa_po_no, loa_po_amount, loa_po_date, gross_amount, total_additions, total_deductions, net_payable_amount, net_payable_round_off, net_payable_words, tds_percentage, tds_section, tds_amount, account_holder_name, bank_name, account_number, ifsc_code, recommendation_of_payment, status, is_draft, auto_created, created_by, hold_reason, hold_date, hold_by, utr_no, utr_date, created_at, updated_at FROM payment_notes
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetPaymentNoteByID(ctx context.Context, id int64) (PaymentNote, error) {
	row := q.db.QueryRowContext(ctx, getPaymentNoteByID, id)
	var i PaymentNote
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GreenNoteID,
		&i.GreenNoteNo,
		&i.GreenNoteApprover,
		&i.GreenNoteAppDate,
		&i.ReimbursementNoteID,
		&i.NoteNo,
		&i.Subject,
		&i.Date,
		&i.Department,
		&i.VendorCode,
		&i.VendorName,
		&i.ProjectName,
		&i.InvoiceNo,
		&i.InvoiceDate,
		&i.InvoiceAmount,
		&i.InvoiceApprovedBy,
		&i.LoaPoNo,
		&i.LoaPoAmount,
		&i.LoaPoDate,
		&i.GrossAmount,
		&i.TotalAdditions,
		&i.TotalDeductions,
		&i.NetPayableAmount,
		&i.NetPayableRoundOff,
		&i.NetPayableWords,
		&i.TdsPercentage,
		&i.TdsSection,
		&i.TdsAmount,
		&i.AccountHolderName,
		&i.BankName,
		&i.AccountNumber,
		&i.IfscCode,
		&i.RecommendationOfPayment,
		&i.Status,
		&i.IsDraft,
		&i.AutoCreated,
		&i.CreatedBy,
		&i.HoldReason,
		&i.HoldDate,
		&i.HoldBy,
		&i.UtrNo,
		&i.UtrDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPaymentNoteByNoteNo = `-- name: GetPaymentNoteByNoteNo :one
SELECT id, user_id, green_note_id, green_note_no, green_note_approver, green_note_app_date, reimbursement_note_id, note_no, subject, date, department, vendor_code, vendor_name, project_name, invoice_no, invoice_date, invoice_amount, invoice_approved_by, loa_po_no, loa_po_amount, loa_po_date, gross_amount, total_additions, total_deductions, net_payable_amount, net_payable_round_off, net_payable_words, tds_percentage, tds_section, tds_amount, account_holder_name, bank_name, account_number, ifsc_code, recommendation_of_payment, status, is_draft, auto_created, created_by, hold_reason, hold_date, hold_by, utr_no, utr_date, created_at, updated_at FROM payment_notes
WHERE note_no = $1
LIMIT 1
`

func (q *Queries) GetPaymentNoteByNoteNo(ctx context.Context, noteNo string) (PaymentNote, error) {
	row := q.db.QueryRowContext(ctx, getPaymentNoteByNoteNo, noteNo)
	var i PaymentNote
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GreenNoteID,
		&i.GreenNoteNo,
		&i.GreenNoteApprover,
		&i.GreenNoteAppDate,
		&i.ReimbursementNoteID,
		&i.NoteNo,
		&i.Subject,
		&i.Date,
		&i.Department,
		&i.VendorCode,
		&i.VendorName,
		&i.ProjectName,
		&i.InvoiceNo,
		&i.InvoiceDate,
		&i.InvoiceAmount,
		&i.InvoiceApprovedBy,
		&i.LoaPoNo,
		&i.LoaPoAmount,
		&i.LoaPoDate,
		&i.GrossAmount,
		&i.TotalAdditions,
		&i.TotalDeductions,
		&i.NetPayableAmount,
		&i.NetPayableRoundOff,
		&i.NetPayableWords,
		&i.TdsPercentage,
		&i.TdsSection,
		&i.TdsAmount,
		&i.AccountHolderName,
		&i.BankName,
		&i.AccountNumber,
		&i.IfscCode,
		&i.RecommendationOfPayment,
		&i.Status,
		&i.IsDraft,
		&i.AutoCreated,
		&i.CreatedBy,
		&i.HoldReason,
		&i.HoldDate,
		&i.HoldBy,
		&i.UtrNo,
		&i.UtrDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertApprovalLog = `-- name: InsertApprovalLog :one
INSERT INTO payment_note_approval_logs (
    payment_note_id,
    status,
    comments,
    reviewer_id,
    reviewer_name,
    reviewer_email,
    approver_level
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
)
RETURNING id, payment_note_id, status, comments, reviewer_id, reviewer_name, reviewer_email, approver_level, created_at
`

type InsertApprovalLogParams struct {
	PaymentNoteID int64          `json:"payment_note_id"`
	Status        string         `json:"status"`
	Comments      sql.NullString `json:"comments"`
	ReviewerID    int64          `json:"reviewer_id"`
	ReviewerName  sql.NullString `json:"reviewer_name"`
	ReviewerEmail sql.NullString `json:"reviewer_email"`
	ApproverLevel sql.NullInt32  `json:"approver_level"`
}

func (q *Queries) InsertApprovalLog(ctx context.Context, arg InsertApprovalLogParams) (PaymentNoteApprovalLog, error) {
	row := q.db.QueryRowContext(ctx, insertApprovalLog,
		arg.PaymentNoteID,
		arg.Status,
		arg.Comments,
		arg.ReviewerID,
		arg.ReviewerName,
		arg.ReviewerEmail,
		arg.ApproverLevel,
	)
	var i PaymentNoteApprovalLog
	err := row.Scan(
		&i.ID,
		&i.PaymentNoteID,
		&i.Status,
		&i.Comments,
		&i.ReviewerID,
		&i.ReviewerName,
		&i.ReviewerEmail,
		&i.ApproverLevel,
		&i.CreatedAt,
	)
	return i, err
}

const insertPaymentNoteComment = `-- name: InsertPaymentNoteComment :one
INSERT INTO payment_note_comments (
    payment_note_id,
    comment,
    status,
    user_id,
    user_name,
    user_email
) VALUES (
    $1, $2, $3, $4, $5, $6
)
RETURNING id, payment_note_id, comment, status, user_id, user_name, user_email, created_at
`

type InsertPaymentNoteCommentParams struct {
	PaymentNoteID int64          `json:"payment_note_id"`
	Comment       string         `json:"comment"`
	Status        sql.NullString `json:"status"`
	UserID        int64          `json:"user_id"`
	UserName      sql.NullString `json:"user_name"`
	UserEmail     sql.NullString `json:"user_email"`
}

func (q *Queries) InsertPaymentNoteComment(ctx context.Context, arg InsertPaymentNoteCommentParams) (PaymentNoteComment, error) {
	row := q.db.QueryRowContext(ctx, insertPaymentNoteComment,
		arg.PaymentNoteID,
		arg.Comment,
		arg.Status,
		arg.UserID,
		arg.UserName,
		arg.UserEmail,
	)
	var i PaymentNoteComment
	err := row.Scan(
		&i.ID,
		&i.PaymentNoteID,
		&i.Comment,
		&i.Status,
		&i.UserID,
		&i.UserName,
		&i.UserEmail,
		&i.CreatedAt,
	)
	return i, err
}

const insertPaymentNoteDocument = `-- name: InsertPaymentNoteDocument :one
INSERT INTO payment_note_documents (
    payment_note_id,
    file_name,
    original_filename,
    mime_type,
    file_size,
    object_key,
    uploaded_by,
    uploaded_by_name
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING id, payment_note_id, file_name, original_filename, mime_type, file_size, object_key, uploaded_by, uploaded_by_name, created_at
`

type InsertPaymentNoteDocumentParams struct {
	PaymentNoteID    int64          `json:"payment_note_id"`
	FileName         string         `json:"file_name"`
	OriginalFilename string         `json:"original_filename"`
	MimeType         sql.NullString `json:"mime_type"`
	FileSize         sql.NullInt64  `json:"file_size"`
	ObjectKey        string         `json:"object_key"`
	UploadedBy       int64          `json:"uploaded_by"`
	UploadedByName   sql.NullString `json:"uploaded_by_name"`
}

func (q *Queries) InsertPaymentNoteDocument(ctx context.Context, arg InsertPaymentNoteDocumentParams) (PaymentNoteDocument, error) {
	row := q.db.QueryRowContext(ctx, insertPaymentNoteDocument,
		arg.PaymentNoteID,
		arg.FileName,
		arg.OriginalFilename,
		arg.MimeType,
		arg.FileSize,
		arg.ObjectKey,
		arg.UploadedBy,
		arg.UploadedByName,
	)
	var i PaymentNoteDocument
	err := row.Scan(
		&i.ID,
		&i.PaymentNoteID,
		&i.FileName,
		&i.OriginalFilename,
		&i.MimeType,
		&i.FileSize,
		&i.ObjectKey,
		&i.UploadedBy,
		&i.UploadedByName,
		&i.CreatedAt,
	)
	return i, err
}

const insertPaymentParticular = `-- name: InsertPaymentParticular :one
INSERT INTO payment_note_particulars (
    payment_note_id,
    particular_type,
    particular,
    amount
) VALUES (
    $1, $2, $3, $4
)
RETURNING id, payment_note_id, particular_type, particular, amount, created_at
`

type InsertPaymentParticularParams struct {
	PaymentNoteID  int64  `json:"payment_note_id"`
	ParticularType string `json:"particular_type"`
	Particular     string `json:"particular"`
	Amount         string `json:"amount"`
}

func (q *Queries) InsertPaymentParticular(ctx context.Context, arg InsertPaymentParticularParams) (PaymentNoteParticular, error) {
	row := q.db.QueryRowContext(ctx, insertPaymentParticular,
		arg.PaymentNoteID,
		arg.ParticularType,
		arg.Particular,
		arg.Amount,
	)
	var i PaymentNoteParticular
	err := row.Scan(
		&i.ID,
		&i.PaymentNoteID,
		&i.ParticularType,
		&i.Particular,
		&i.Amount,
		&i.CreatedAt,
	)
	return i, err
}

const listApprovalLogs = `-- name: ListApprovalLogs :many
SELECT id, payment_note_id, status, comments, reviewer_id, reviewer_name, reviewer_email, approver_level, created_at FROM payment_note_approval_logs
WHERE payment_note_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListApprovalLogs(ctx context.Context, paymentNoteID int64) ([]PaymentNoteApprovalLog, error) {
	rows, err := q.db.QueryContext(ctx, listApprovalLogs, paymentNoteID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PaymentNoteApprovalLog
	for rows.Next() {
		var i PaymentNoteApprovalLog
		if err := rows.Scan(
			&i.ID,
			&i.PaymentNoteID,
			&i.Status,
			&i.Comments,
			&i.ReviewerID,
			&i.ReviewerName,
			&i.ReviewerEmail,
			&i.ApproverLevel,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPaymentNoteComments = `-- name: ListPaymentNoteComments :many
SELECT id, payment_note_id, comment, status, user_id, user_name, user_email, created_at FROM payment_note_comments
WHERE payment_note_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListPaymentNoteComments(ctx context.Context, paymentNoteID int64) ([]PaymentNoteComment, error) {
	rows, err := q.db.QueryContext(ctx, listPaymentNoteComments, paymentNoteID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PaymentNoteComment
	for rows.Next() {
		var i PaymentNoteComment
		if err := rows.Scan(
			&i.ID,
			&i.PaymentNoteID,
			&i.Comment,
			&i.Status,
			&i.UserID,
			&i.UserName,
			&i.UserEmail,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPaymentNoteDocuments = `-- name: ListPaymentNoteDocuments :many
SELECT id, payment_note_id, file_name, original_filename, mime_type, file_size, object_key, uploaded_by, uploaded_by_name, created_at FROM payment_note_documents
WHERE payment_note_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListPaymentNoteDocuments(ctx context.Context, paymentNoteID int64) ([]PaymentNoteDocument, error) {
	rows, err := q.db.QueryContext(ctx, listPaymentNoteDocuments, paymentNoteID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PaymentNoteDocument
	for rows.Next() {
		var i PaymentNoteDocument
		if err := rows.Scan(
			&i.ID,
			&i.PaymentNoteID,
			&i.FileName,
			&i.OriginalFilename,
			&i.MimeType,
			&i.FileSize,
			&i.ObjectKey,
			&i.UploadedBy,
			&i.UploadedByName,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPaymentNotes = `-- name: ListPaymentNotes :many
SELECT id, user_id, green_note_id, green_note_no, green_note_approver, green_note_app_date, reimbursement_note_id, note_no, subject, date, department, vendor_code, vendor_name, project_name, invoice_no, invoice_date, invoice_amount, invoice_approved_by, loa_po_no, loa_po_amount, loa_po_date, gross_amount, total_additions, total_deductions, net_payable_amount, net_payable_round_off, net_payable_words, tds_percentage, tds_section, tds_amount, account_holder_name, bank_name, account_number, ifsc_code, recommendation_of_payment, status, is_draft, auto_created, created_by, hold_reason, hold_date, hold_by, utr_no, utr_date, created_at, updated_at FROM payment_notes
WHERE
    ($1::text IS NULL OR status = $1) AND
    ($2::boolean IS NULL OR is_draft = $2) AND
    ($3::text IS NULL OR (
        note_no ILIKE '%' || $3 || '%' OR
        subject ILIKE '%' || $3 || '%' OR
        vendor_name ILIKE '%' || $3 || '%' OR
        project_name ILIKE '%' || $3 || '%'
    ))
ORDER BY created_at DESC
LIMIT $4 OFFSET $5
`

type ListPaymentNotesParams struct {
	Column1 string `json:"column_1"`
	Column2 bool   `json:"column_2"`
	Column3 string `json:"column_3"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

func (q *Queries) ListPaymentNotes(ctx context.Context, arg ListPaymentNotesParams) ([]PaymentNote, error) {
	rows, err := q.db.QueryContext(ctx, listPaymentNotes,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PaymentNote
	for rows.Next() {
		var i PaymentNote
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.GreenNoteID,
			&i.GreenNoteNo,
			&i.GreenNoteApprover,
			&i.GreenNoteAppDate,
			&i.ReimbursementNoteID,
			&i.NoteNo,
			&i.Subject,
			&i.Date,
			&i.Department,
			&i.VendorCode,
			&i.VendorName,
			&i.ProjectName,
			&i.InvoiceNo,
			&i.InvoiceDate,
			&i.InvoiceAmount,
			&i.InvoiceApprovedBy,
			&i.LoaPoNo,
			&i.LoaPoAmount,
			&i.LoaPoDate,
			&i.GrossAmount,
			&i.TotalAdditions,
			&i.TotalDeductions,
			&i.NetPayableAmount,
			&i.NetPayableRoundOff,
			&i.NetPayableWords,
			&i.TdsPercentage,
			&i.TdsSection,
			&i.TdsAmount,
			&i.AccountHolderName,
			&i.BankName,
			&i.AccountNumber,
			&i.IfscCode,
			&i.RecommendationOfPayment,
			&i.Status,
			&i.IsDraft,
			&i.AutoCreated,
			&i.CreatedBy,
			&i.HoldReason,
			&i.HoldDate,
			&i.HoldBy,
			&i.UtrNo,
			&i.UtrDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPaymentParticulars = `-- name: ListPaymentParticulars :many
SELECT id, payment_note_id, particular_type, particular, amount, created_at FROM payment_note_particulars
WHERE payment_note_id = $1
ORDER BY id ASC
`

func (q *Queries) ListPaymentParticulars(ctx context.Context, paymentNoteID int64) ([]PaymentNoteParticular, error) {
	rows, err := q.db.QueryContext(ctx, listPaymentParticulars, paymentNoteID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PaymentNoteParticular
	for rows.Next() {
		var i PaymentNoteParticular
		if err := rows.Scan(
			&i.ID,
			&i.PaymentNoteID,
			&i.ParticularType,
			&i.Particular,
			&i.Amount,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const putPaymentNoteOnHold = `-- name: PutPaymentNoteOnHold :one
UPDATE payment_notes
SET
    status = 'H',
    hold_reason = $2,
    hold_date = NOW(),
    hold_by = $3,
    updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, green_note_id, green_note_no, green_note_approver, green_note_app_date, reimbursement_note_id, note_no, subject, date, department, vendor_code, vendor_name, project_name, invoice_no, invoice_date, invoice_amount, invoice_approved_by, loa_po_no, loa_po_amount, loa_po_date, gross_amount, total_additions, total_deductions, net_payable_amount, net_payable_round_off, net_payable_words, tds_percentage, tds_section, tds_amount, account_holder_name, bank_name, account_number, ifsc_code, recommendation_of_payment, status, is_draft, auto_created, created_by, hold_reason, hold_date, hold_by, utr_no, utr_date, created_at, updated_at
`

type PutPaymentNoteOnHoldParams struct {
	ID         int64          `json:"id"`
	HoldReason sql.NullString `json:"hold_reason"`
	HoldBy     sql.NullInt64  `json:"hold_by"`
}

func (q *Queries) PutPaymentNoteOnHold(ctx context.Context, arg PutPaymentNoteOnHoldParams) (PaymentNote, error) {
	row := q.db.QueryRowContext(ctx, putPaymentNoteOnHold, arg.ID, arg.HoldReason, arg.HoldBy)
	var i PaymentNote
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GreenNoteID,
		&i.GreenNoteNo,
		&i.GreenNoteApprover,
		&i.GreenNoteAppDate,
		&i.ReimbursementNoteID,
		&i.NoteNo,
		&i.Subject,
		&i.Date,
		&i.Department,
		&i.VendorCode,
		&i.VendorName,
		&i.ProjectName,
		&i.InvoiceNo,
		&i.InvoiceDate,
		&i.InvoiceAmount,
		&i.InvoiceApprovedBy,
		&i.LoaPoNo,
		&i.LoaPoAmount,
		&i.LoaPoDate,
		&i.GrossAmount,
		&i.TotalAdditions,
		&i.TotalDeductions,
		&i.NetPayableAmount,
		&i.NetPayableRoundOff,
		&i.NetPayableWords,
		&i.TdsPercentage,
		&i.TdsSection,
		&i.TdsAmount,
		&i.AccountHolderName,
		&i.BankName,
		&i.AccountNumber,
		&i.IfscCode,
		&i.RecommendationOfPayment,
		&i.Status,
		&i.IsDraft,
		&i.AutoCreated,
		&i.CreatedBy,
		&i.HoldReason,
		&i.HoldDate,
		&i.HoldBy,
		&i.UtrNo,
		&i.UtrDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const removePaymentNoteFromHold = `-- name: RemovePaymentNoteFromHold :one
UPDATE payment_notes
SET
    status = $2,
    hold_reason = NULL,
    hold_date = NULL,
    hold_by = NULL,
    updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, green_note_id, green_note_no, green_note_approver, green_note_app_date, reimbursement_note_id, note_no, subject, date, department, vendor_code, vendor_name, project_name, invoice_no, invoice_date, invoice_amount, invoice_approved_by, loa_po_no, loa_po_amount, loa_po_date, gross_amount, total_additions, total_deductions, net_payable_amount, net_payable_round_off, net_payable_words, tds_percentage, tds_section, tds_amount, account_holder_name, bank_name, account_number, ifsc_code, recommendation_of_payment, status, is_draft, auto_created, created_by, hold_reason, hold_date, hold_by, utr_no, utr_date, created_at, updated_at
`

type RemovePaymentNoteFromHoldParams struct {
	ID     int64                 `json:"id"`
	Status NullPaymentNoteStatus `json:"status"`
}

func (q *Queries) RemovePaymentNoteFromHold(ctx context.Context, arg RemovePaymentNoteFromHoldParams) (PaymentNote, error) {
	row := q.db.QueryRowContext(ctx, removePaymentNoteFromHold, arg.ID, arg.Status)
	var i PaymentNote
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GreenNoteID,
		&i.GreenNoteNo,
		&i.GreenNoteApprover,
		&i.GreenNoteAppDate,
		&i.ReimbursementNoteID,
		&i.NoteNo,
		&i.Subject,
		&i.Date,
		&i.Department,
		&i.VendorCode,
		&i.VendorName,
		&i.ProjectName,
		&i.InvoiceNo,
		&i.InvoiceDate,
		&i.InvoiceAmount,
		&i.InvoiceApprovedBy,
		&i.LoaPoNo,
		&i.LoaPoAmount,
		&i.LoaPoDate,
		&i.GrossAmount,
		&i.TotalAdditions,
		&i.TotalDeductions,
		&i.NetPayableAmount,
		&i.NetPayableRoundOff,
		&i.NetPayableWords,
		&i.TdsPercentage,
		&i.TdsSection,
		&i.TdsAmount,
		&i.AccountHolderName,
		&i.BankName,
		&i.AccountNumber,
		&i.IfscCode,
		&i.RecommendationOfPayment,
		&i.Status,
		&i.IsDraft,
		&i.AutoCreated,
		&i.CreatedBy,
		&i.HoldReason,
		&i.HoldDate,
		&i.HoldBy,
		&i.UtrNo,
		&i.UtrDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePaymentNote = `-- name: UpdatePaymentNote :one
UPDATE payment_notes
SET
    user_id = $2,
    green_note_id = $3,
    green_note_no = $4,
    green_note_approver = $5,
    green_note_app_date = $6,
    reimbursement_note_id = $7,
    subject = $8,
    date = $9,
    department = $10,
    vendor_code = $11,
    vendor_name = $12,
    project_name = $13,
    invoice_no = $14,
    invoice_date = $15,
    invoice_amount = $16,
    invoice_approved_by = $17,
    loa_po_no = $18,
    loa_po_amount = $19,
    loa_po_date = $20,
    gross_amount = $21,
    total_additions = $22,
    total_deductions = $23,
    net_payable_amount = $24,
    net_payable_round_off = $25,
    net_payable_words = $26,
    tds_percentage = $27,
    tds_section = $28,
    tds_amount = $29,
    account_holder_name = $30,
    bank_name = $31,
    account_number = $32,
    ifsc_code = $33,
    recommendation_of_payment = $34,
    status = $35,
    is_draft = $36,
    updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, green_note_id, green_note_no, green_note_approver, green_note_app_date, reimbursement_note_id, note_no, subject, date, department, vendor_code, vendor_name, project_name, invoice_no, invoice_date, invoice_amount, invoice_approved_by, loa_po_no, loa_po_amount, loa_po_date, gross_amount, total_additions, total_deductions, net_payable_amount, net_payable_round_off, net_payable_words, tds_percentage, tds_section, tds_amount, account_holder_name, bank_name, account_number, ifsc_code, recommendation_of_payment, status, is_draft, auto_created, created_by, hold_reason, hold_date, hold_by, utr_no, utr_date, created_at, updated_at
`

type UpdatePaymentNoteParams struct {
	ID                      int64                 `json:"id"`
	UserID                  int64                 `json:"user_id"`
	GreenNoteID             sql.NullString        `json:"green_note_id"`
	GreenNoteNo             sql.NullString        `json:"green_note_no"`
	GreenNoteApprover       sql.NullString        `json:"green_note_approver"`
	GreenNoteAppDate        sql.NullString        `json:"green_note_app_date"`
	ReimbursementNoteID     sql.NullInt64         `json:"reimbursement_note_id"`
	Subject                 sql.NullString        `json:"subject"`
	Date                    sql.NullTime          `json:"date"`
	Department              sql.NullString        `json:"department"`
	VendorCode              sql.NullString        `json:"vendor_code"`
	VendorName              sql.NullString        `json:"vendor_name"`
	ProjectName             sql.NullString        `json:"project_name"`
	InvoiceNo               sql.NullString        `json:"invoice_no"`
	InvoiceDate             sql.NullString        `json:"invoice_date"`
	InvoiceAmount           sql.NullString        `json:"invoice_amount"`
	InvoiceApprovedBy       sql.NullString        `json:"invoice_approved_by"`
	LoaPoNo                 sql.NullString        `json:"loa_po_no"`
	LoaPoAmount             sql.NullString        `json:"loa_po_amount"`
	LoaPoDate               sql.NullString        `json:"loa_po_date"`
	GrossAmount             string                `json:"gross_amount"`
	TotalAdditions          string                `json:"total_additions"`
	TotalDeductions         string                `json:"total_deductions"`
	NetPayableAmount        string                `json:"net_payable_amount"`
	NetPayableRoundOff      string                `json:"net_payable_round_off"`
	NetPayableWords         sql.NullString        `json:"net_payable_words"`
	TdsPercentage           sql.NullString        `json:"tds_percentage"`
	TdsSection              sql.NullString        `json:"tds_section"`
	TdsAmount               sql.NullString        `json:"tds_amount"`
	AccountHolderName       sql.NullString        `json:"account_holder_name"`
	BankName                sql.NullString        `json:"bank_name"`
	AccountNumber           sql.NullString        `json:"account_number"`
	IfscCode                sql.NullString        `json:"ifsc_code"`
	RecommendationOfPayment sql.NullString        `json:"recommendation_of_payment"`
	Status                  NullPaymentNoteStatus `json:"status"`
	IsDraft                 bool                  `json:"is_draft"`
}

func (q *Queries) UpdatePaymentNote(ctx context.Context, arg UpdatePaymentNoteParams) (PaymentNote, error) {
	row := q.db.QueryRowContext(ctx, updatePaymentNote,
		arg.ID,
		arg.UserID,
		arg.GreenNoteID,
		arg.GreenNoteNo,
		arg.GreenNoteApprover,
		arg.GreenNoteAppDate,
		arg.ReimbursementNoteID,
		arg.Subject,
		arg.Date,
		arg.Department,
		arg.VendorCode,
		arg.VendorName,
		arg.ProjectName,
		arg.InvoiceNo,
		arg.InvoiceDate,
		arg.InvoiceAmount,
		arg.InvoiceApprovedBy,
		arg.LoaPoNo,
		arg.LoaPoAmount,
		arg.LoaPoDate,
		arg.GrossAmount,
		arg.TotalAdditions,
		arg.TotalDeductions,
		arg.NetPayableAmount,
		arg.NetPayableRoundOff,
		arg.NetPayableWords,
		arg.TdsPercentage,
		arg.TdsSection,
		arg.TdsAmount,
		arg.AccountHolderName,
		arg.BankName,
		arg.AccountNumber,
		arg.IfscCode,
		arg.RecommendationOfPayment,
		arg.Status,
		arg.IsDraft,
	)
	var i PaymentNote
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GreenNoteID,
		&i.GreenNoteNo,
		&i.GreenNoteApprover,
		&i.GreenNoteAppDate,
		&i.ReimbursementNoteID,
		&i.NoteNo,
		&i.Subject,
		&i.Date,
		&i.Department,
		&i.VendorCode,
		&i.VendorName,
		&i.ProjectName,
		&i.InvoiceNo,
		&i.InvoiceDate,
		&i.InvoiceAmount,
		&i.InvoiceApprovedBy,
		&i.LoaPoNo,
		&i.LoaPoAmount,
		&i.LoaPoDate,
		&i.GrossAmount,
		&i.TotalAdditions,
		&i.TotalDeductions,
		&i.NetPayableAmount,
		&i.NetPayableRoundOff,
		&i.NetPayableWords,
		&i.TdsPercentage,
		&i.TdsSection,
		&i.TdsAmount,
		&i.AccountHolderName,
		&i.BankName,
		&i.AccountNumber,
		&i.IfscCode,
		&i.RecommendationOfPayment,
		&i.Status,
		&i.IsDraft,
		&i.AutoCreated,
		&i.CreatedBy,
		&i.HoldReason,
		&i.HoldDate,
		&i.HoldBy,
		&i.UtrNo,
		&i.UtrDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePaymentNoteStatus = `-- name: UpdatePaymentNoteStatus :one
UPDATE payment_notes
SET
    status = $2,
    is_draft = $3,
    updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, green_note_id, green_note_no, green_note_approver, green_note_app_date, reimbursement_note_id, note_no, subject, date, department, vendor_code, vendor_name, project_name, invoice_no, invoice_date, invoice_amount, invoice_approved_by, loa_po_no, loa_po_amount, loa_po_date, gross_amount, total_additions, total_deductions, net_payable_amount, net_payable_round_off, net_payable_words, tds_percentage, tds_section, tds_amount, account_holder_name, bank_name, account_number, ifsc_code, recommendation_of_payment, status, is_draft, auto_created, created_by, hold_reason, hold_date, hold_by, utr_no, utr_date, created_at, updated_at
`

type UpdatePaymentNoteStatusParams struct {
	ID      int64                 `json:"id"`
	Status  NullPaymentNoteStatus `json:"status"`
	IsDraft bool                  `json:"is_draft"`
}

func (q *Queries) UpdatePaymentNoteStatus(ctx context.Context, arg UpdatePaymentNoteStatusParams) (PaymentNote, error) {
	row := q.db.QueryRowContext(ctx, updatePaymentNoteStatus, arg.ID, arg.Status, arg.IsDraft)
	var i PaymentNote
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GreenNoteID,
		&i.GreenNoteNo,
		&i.GreenNoteApprover,
		&i.GreenNoteAppDate,
		&i.ReimbursementNoteID,
		&i.NoteNo,
		&i.Subject,
		&i.Date,
		&i.Department,
		&i.VendorCode,
		&i.VendorName,
		&i.ProjectName,
		&i.InvoiceNo,
		&i.InvoiceDate,
		&i.InvoiceAmount,
		&i.InvoiceApprovedBy,
		&i.LoaPoNo,
		&i.LoaPoAmount,
		&i.LoaPoDate,
		&i.GrossAmount,
		&i.TotalAdditions,
		&i.TotalDeductions,
		&i.NetPayableAmount,
		&i.NetPayableRoundOff,
		&i.NetPayableWords,
		&i.TdsPercentage,
		&i.TdsSection,
		&i.TdsAmount,
		&i.AccountHolderName,
		&i.BankName,
		&i.AccountNumber,
		&i.IfscCode,
		&i.RecommendationOfPayment,
		&i.Status,
		&i.IsDraft,
		&i.AutoCreated,
		&i.CreatedBy,
		&i.HoldReason,
		&i.HoldDate,
		&i.HoldBy,
		&i.UtrNo,
		&i.UtrDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePaymentNoteUTR = `-- name: UpdatePaymentNoteUTR :one
UPDATE payment_notes
SET
    utr_no = $2,
    utr_date = $3,
    updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, green_note_id, green_note_no, green_note_approver, green_note_app_date, reimbursement_note_id, note_no, subject, date, department, vendor_code, vendor_name, project_name, invoice_no, invoice_date, invoice_amount, invoice_approved_by, loa_po_no, loa_po_amount, loa_po_date, gross_amount, total_additions, total_deductions, net_payable_amount, net_payable_round_off, net_payable_words, tds_percentage, tds_section, tds_amount, account_holder_name, bank_name, account_number, ifsc_code, recommendation_of_payment, status, is_draft, auto_created, created_by, hold_reason, hold_date, hold_by, utr_no, utr_date, created_at, updated_at
`

type UpdatePaymentNoteUTRParams struct {
	ID      int64          `json:"id"`
	UtrNo   sql.NullString `json:"utr_no"`
	UtrDate sql.NullString `json:"utr_date"`
}

func (q *Queries) UpdatePaymentNoteUTR(ctx context.Context, arg UpdatePaymentNoteUTRParams) (PaymentNote, error) {
	row := q.db.QueryRowContext(ctx, updatePaymentNoteUTR, arg.ID, arg.UtrNo, arg.UtrDate)
	var i PaymentNote
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GreenNoteID,
		&i.GreenNoteNo,
		&i.GreenNoteApprover,
		&i.GreenNoteAppDate,
		&i.ReimbursementNoteID,
		&i.NoteNo,
		&i.Subject,
		&i.Date,
		&i.Department,
		&i.VendorCode,
		&i.VendorName,
		&i.ProjectName,
		&i.InvoiceNo,
		&i.InvoiceDate,
		&i.InvoiceAmount,
		&i.InvoiceApprovedBy,
		&i.LoaPoNo,
		&i.LoaPoAmount,
		&i.LoaPoDate,
		&i.GrossAmount,
		&i.TotalAdditions,
		&i.TotalDeductions,
		&i.NetPayableAmount,
		&i.NetPayableRoundOff,
		&i.NetPayableWords,
		&i.TdsPercentage,
		&i.TdsSection,
		&i.TdsAmount,
		&i.AccountHolderName,
		&i.BankName,
		&i.AccountNumber,
		&i.IfscCode,
		&i.RecommendationOfPayment,
		&i.Status,
		&i.IsDraft,
		&i.AutoCreated,
		&i.CreatedBy,
		&i.HoldReason,
		&i.HoldDate,
		&i.HoldBy,
		&i.UtrNo,
		&i.UtrDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
