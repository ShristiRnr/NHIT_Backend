// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: payment.sql

package generated

import (
	"context"
	"database/sql"
)

const countPaymentGroups = `-- name: CountPaymentGroups :one
SELECT COUNT(DISTINCT sl_no)
FROM payments
WHERE 
    ($1::text IS NULL OR status::text = $1) AND
    ($2::boolean IS NULL OR (user_id = $3))
`

type CountPaymentGroupsParams struct {
	Column1 string `json:"column_1"`
	Column2 bool   `json:"column_2"`
	UserID  int64  `json:"user_id"`
}

func (q *Queries) CountPaymentGroups(ctx context.Context, arg CountPaymentGroupsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPaymentGroups, arg.Column1, arg.Column2, arg.UserID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPayment = `-- name: CreatePayment :one
INSERT INTO payments (
    sl_no,
    template_type,
    project,
    account_full_name,
    from_account_type,
    full_account_number,
    to_account,
    to_account_type,
    name_of_beneficiary,
    account_number,
    name_of_bank,
    ifsc_code,
    amount,
    purpose,
    status,
    user_id,
    payment_note_id
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17
)
RETURNING id, sl_no, template_type, project, account_full_name, from_account_type, full_account_number, to_account, to_account_type, name_of_beneficiary, account_number, name_of_bank, ifsc_code, amount, purpose, status, user_id, payment_note_id, created_at, updated_at
`

type CreatePaymentParams struct {
	SlNo              string            `json:"sl_no"`
	TemplateType      TemplateType      `json:"template_type"`
	Project           sql.NullString    `json:"project"`
	AccountFullName   sql.NullString    `json:"account_full_name"`
	FromAccountType   sql.NullString    `json:"from_account_type"`
	FullAccountNumber sql.NullString    `json:"full_account_number"`
	ToAccount         sql.NullString    `json:"to_account"`
	ToAccountType     sql.NullString    `json:"to_account_type"`
	NameOfBeneficiary sql.NullString    `json:"name_of_beneficiary"`
	AccountNumber     sql.NullString    `json:"account_number"`
	NameOfBank        sql.NullString    `json:"name_of_bank"`
	IfscCode          sql.NullString    `json:"ifsc_code"`
	Amount            string            `json:"amount"`
	Purpose           sql.NullString    `json:"purpose"`
	Status            NullPaymentStatus `json:"status"`
	UserID            int64             `json:"user_id"`
	PaymentNoteID     sql.NullInt64     `json:"payment_note_id"`
}

func (q *Queries) CreatePayment(ctx context.Context, arg CreatePaymentParams) (Payment, error) {
	row := q.db.QueryRowContext(ctx, createPayment,
		arg.SlNo,
		arg.TemplateType,
		arg.Project,
		arg.AccountFullName,
		arg.FromAccountType,
		arg.FullAccountNumber,
		arg.ToAccount,
		arg.ToAccountType,
		arg.NameOfBeneficiary,
		arg.AccountNumber,
		arg.NameOfBank,
		arg.IfscCode,
		arg.Amount,
		arg.Purpose,
		arg.Status,
		arg.UserID,
		arg.PaymentNoteID,
	)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.SlNo,
		&i.TemplateType,
		&i.Project,
		&i.AccountFullName,
		&i.FromAccountType,
		&i.FullAccountNumber,
		&i.ToAccount,
		&i.ToAccountType,
		&i.NameOfBeneficiary,
		&i.AccountNumber,
		&i.NameOfBank,
		&i.IfscCode,
		&i.Amount,
		&i.Purpose,
		&i.Status,
		&i.UserID,
		&i.PaymentNoteID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createPaymentShortcut = `-- name: CreatePaymentShortcut :one
INSERT INTO payment_shortcuts (
    sl_no,
    shortcut_name,
    request_data_json,
    user_id
) VALUES (
    $1, $2, $3, $4
)
RETURNING id, sl_no, shortcut_name, request_data_json, user_id, created_at, updated_at
`

type CreatePaymentShortcutParams struct {
	SlNo            sql.NullString `json:"sl_no"`
	ShortcutName    string         `json:"shortcut_name"`
	RequestDataJson string         `json:"request_data_json"`
	UserID          int64          `json:"user_id"`
}

func (q *Queries) CreatePaymentShortcut(ctx context.Context, arg CreatePaymentShortcutParams) (PaymentShortcut, error) {
	row := q.db.QueryRowContext(ctx, createPaymentShortcut,
		arg.SlNo,
		arg.ShortcutName,
		arg.RequestDataJson,
		arg.UserID,
	)
	var i PaymentShortcut
	err := row.Scan(
		&i.ID,
		&i.SlNo,
		&i.ShortcutName,
		&i.RequestDataJson,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deletePayment = `-- name: DeletePayment :exec
DELETE FROM payments
WHERE id = $1
`

func (q *Queries) DeletePayment(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deletePayment, id)
	return err
}

const deletePaymentsBySlNo = `-- name: DeletePaymentsBySlNo :exec
DELETE FROM payments
WHERE sl_no = $1
`

func (q *Queries) DeletePaymentsBySlNo(ctx context.Context, slNo string) error {
	_, err := q.db.ExecContext(ctx, deletePaymentsBySlNo, slNo)
	return err
}

const generateSerialNumber = `-- name: GenerateSerialNumber :one
SELECT COALESCE(MAX(CAST(SUBSTRING(sl_no FROM '[0-9]+$') AS INTEGER)), 0) + 1 AS next_number
FROM payments
WHERE sl_no LIKE $1 || '%'
`

func (q *Queries) GenerateSerialNumber(ctx context.Context, dollar_1 sql.NullString) (int32, error) {
	row := q.db.QueryRowContext(ctx, generateSerialNumber, dollar_1)
	var next_number int32
	err := row.Scan(&next_number)
	return next_number, err
}

const getPaymentByID = `-- name: GetPaymentByID :one
SELECT id, sl_no, template_type, project, account_full_name, from_account_type, full_account_number, to_account, to_account_type, name_of_beneficiary, account_number, name_of_bank, ifsc_code, amount, purpose, status, user_id, payment_note_id, created_at, updated_at
FROM payments
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetPaymentByID(ctx context.Context, id int64) (Payment, error) {
	row := q.db.QueryRowContext(ctx, getPaymentByID, id)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.SlNo,
		&i.TemplateType,
		&i.Project,
		&i.AccountFullName,
		&i.FromAccountType,
		&i.FullAccountNumber,
		&i.ToAccount,
		&i.ToAccountType,
		&i.NameOfBeneficiary,
		&i.AccountNumber,
		&i.NameOfBank,
		&i.IfscCode,
		&i.Amount,
		&i.Purpose,
		&i.Status,
		&i.UserID,
		&i.PaymentNoteID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPaymentShortcut = `-- name: GetPaymentShortcut :one
SELECT id, sl_no, shortcut_name, request_data_json, user_id, created_at, updated_at
FROM payment_shortcuts
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetPaymentShortcut(ctx context.Context, id int64) (PaymentShortcut, error) {
	row := q.db.QueryRowContext(ctx, getPaymentShortcut, id)
	var i PaymentShortcut
	err := row.Scan(
		&i.ID,
		&i.SlNo,
		&i.ShortcutName,
		&i.RequestDataJson,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPaymentVendorAccounts = `-- name: GetPaymentVendorAccounts :many
SELECT id, payment_id, vendor_id, vendor_account_id, created_at
FROM payment_vendor_accounts
WHERE payment_id = $1
`

func (q *Queries) GetPaymentVendorAccounts(ctx context.Context, paymentID int64) ([]PaymentVendorAccount, error) {
	rows, err := q.db.QueryContext(ctx, getPaymentVendorAccounts, paymentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PaymentVendorAccount
	for rows.Next() {
		var i PaymentVendorAccount
		if err := rows.Scan(
			&i.ID,
			&i.PaymentID,
			&i.VendorID,
			&i.VendorAccountID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaymentsBySlNo = `-- name: GetPaymentsBySlNo :many
SELECT id, sl_no, template_type, project, account_full_name, from_account_type, full_account_number, to_account, to_account_type, name_of_beneficiary, account_number, name_of_bank, ifsc_code, amount, purpose, status, user_id, payment_note_id, created_at, updated_at
FROM payments
WHERE sl_no = $1
ORDER BY id ASC
`

func (q *Queries) GetPaymentsBySlNo(ctx context.Context, slNo string) ([]Payment, error) {
	rows, err := q.db.QueryContext(ctx, getPaymentsBySlNo, slNo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Payment
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.SlNo,
			&i.TemplateType,
			&i.Project,
			&i.AccountFullName,
			&i.FromAccountType,
			&i.FullAccountNumber,
			&i.ToAccount,
			&i.ToAccountType,
			&i.NameOfBeneficiary,
			&i.AccountNumber,
			&i.NameOfBank,
			&i.IfscCode,
			&i.Amount,
			&i.Purpose,
			&i.Status,
			&i.UserID,
			&i.PaymentNoteID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertBankLetterLog = `-- name: InsertBankLetterLog :one
INSERT INTO bank_letter_approval_logs (
    sl_no,
    status,
    comments,
    reviewer_id,
    reviewer_name,
    reviewer_email,
    approver_level
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
)
RETURNING id, sl_no, status, comments, reviewer_id, reviewer_name, reviewer_email, approver_level, created_at
`

type InsertBankLetterLogParams struct {
	SlNo          string         `json:"sl_no"`
	Status        string         `json:"status"`
	Comments      sql.NullString `json:"comments"`
	ReviewerID    int64          `json:"reviewer_id"`
	ReviewerName  sql.NullString `json:"reviewer_name"`
	ReviewerEmail sql.NullString `json:"reviewer_email"`
	ApproverLevel sql.NullInt32  `json:"approver_level"`
}

func (q *Queries) InsertBankLetterLog(ctx context.Context, arg InsertBankLetterLogParams) (BankLetterApprovalLog, error) {
	row := q.db.QueryRowContext(ctx, insertBankLetterLog,
		arg.SlNo,
		arg.Status,
		arg.Comments,
		arg.ReviewerID,
		arg.ReviewerName,
		arg.ReviewerEmail,
		arg.ApproverLevel,
	)
	var i BankLetterApprovalLog
	err := row.Scan(
		&i.ID,
		&i.SlNo,
		&i.Status,
		&i.Comments,
		&i.ReviewerID,
		&i.ReviewerName,
		&i.ReviewerEmail,
		&i.ApproverLevel,
		&i.CreatedAt,
	)
	return i, err
}

const insertPaymentVendorAccount = `-- name: InsertPaymentVendorAccount :one
INSERT INTO payment_vendor_accounts (
    payment_id,
    vendor_id,
    vendor_account_id
) VALUES (
    $1, $2, $3
)
ON CONFLICT (payment_id, vendor_id) DO NOTHING
RETURNING id, payment_id, vendor_id, vendor_account_id, created_at
`

type InsertPaymentVendorAccountParams struct {
	PaymentID       int64         `json:"payment_id"`
	VendorID        int64         `json:"vendor_id"`
	VendorAccountID sql.NullInt64 `json:"vendor_account_id"`
}

func (q *Queries) InsertPaymentVendorAccount(ctx context.Context, arg InsertPaymentVendorAccountParams) (PaymentVendorAccount, error) {
	row := q.db.QueryRowContext(ctx, insertPaymentVendorAccount, arg.PaymentID, arg.VendorID, arg.VendorAccountID)
	var i PaymentVendorAccount
	err := row.Scan(
		&i.ID,
		&i.PaymentID,
		&i.VendorID,
		&i.VendorAccountID,
		&i.CreatedAt,
	)
	return i, err
}

const listBankLetterLogs = `-- name: ListBankLetterLogs :many
SELECT id, sl_no, status, comments, reviewer_id, reviewer_name, reviewer_email, approver_level, created_at
FROM bank_letter_approval_logs
WHERE sl_no = $1
ORDER BY created_at DESC
`

func (q *Queries) ListBankLetterLogs(ctx context.Context, slNo string) ([]BankLetterApprovalLog, error) {
	rows, err := q.db.QueryContext(ctx, listBankLetterLogs, slNo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BankLetterApprovalLog
	for rows.Next() {
		var i BankLetterApprovalLog
		if err := rows.Scan(
			&i.ID,
			&i.SlNo,
			&i.Status,
			&i.Comments,
			&i.ReviewerID,
			&i.ReviewerName,
			&i.ReviewerEmail,
			&i.ApproverLevel,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPaymentShortcuts = `-- name: ListPaymentShortcuts :many
SELECT id, sl_no, shortcut_name, request_data_json, user_id, created_at, updated_at
FROM payment_shortcuts
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListPaymentShortcuts(ctx context.Context, userID int64) ([]PaymentShortcut, error) {
	rows, err := q.db.QueryContext(ctx, listPaymentShortcuts, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PaymentShortcut
	for rows.Next() {
		var i PaymentShortcut
		if err := rows.Scan(
			&i.ID,
			&i.SlNo,
			&i.ShortcutName,
			&i.RequestDataJson,
			&i.UserID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPayments = `-- name: ListPayments :many
SELECT DISTINCT sl_no, MAX(created_at) as latest_created_at, MAX(status::text) as status
FROM payments
WHERE 
    ($1::text IS NULL OR status::text = $1) AND
    ($2::boolean IS NULL OR (user_id = $3))
GROUP BY sl_no
ORDER BY latest_created_at DESC
LIMIT $4 OFFSET $5
`

type ListPaymentsParams struct {
	Column1 string `json:"column_1"`
	Column2 bool   `json:"column_2"`
	UserID  int64  `json:"user_id"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type ListPaymentsRow struct {
	SlNo            string      `json:"sl_no"`
	LatestCreatedAt interface{} `json:"latest_created_at"`
	Status          interface{} `json:"status"`
}

func (q *Queries) ListPayments(ctx context.Context, arg ListPaymentsParams) ([]ListPaymentsRow, error) {
	rows, err := q.db.QueryContext(ctx, listPayments,
		arg.Column1,
		arg.Column2,
		arg.UserID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPaymentsRow
	for rows.Next() {
		var i ListPaymentsRow
		if err := rows.Scan(&i.SlNo, &i.LatestCreatedAt, &i.Status); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePayment = `-- name: UpdatePayment :one
UPDATE payments
SET
    template_type = $2,
    project = $3,
    account_full_name = $4,
    from_account_type = $5,
    full_account_number = $6,
    to_account = $7,
    to_account_type = $8,
    name_of_beneficiary = $9,
    account_number = $10,
    name_of_bank = $11,
    ifsc_code = $12,
    amount = $13,
    purpose = $14,
    status = $15,
    updated_at = NOW()
WHERE id = $1
RETURNING id, sl_no, template_type, project, account_full_name, from_account_type, full_account_number, to_account, to_account_type, name_of_beneficiary, account_number, name_of_bank, ifsc_code, amount, purpose, status, user_id, payment_note_id, created_at, updated_at
`

type UpdatePaymentParams struct {
	ID                int64             `json:"id"`
	TemplateType      TemplateType      `json:"template_type"`
	Project           sql.NullString    `json:"project"`
	AccountFullName   sql.NullString    `json:"account_full_name"`
	FromAccountType   sql.NullString    `json:"from_account_type"`
	FullAccountNumber sql.NullString    `json:"full_account_number"`
	ToAccount         sql.NullString    `json:"to_account"`
	ToAccountType     sql.NullString    `json:"to_account_type"`
	NameOfBeneficiary sql.NullString    `json:"name_of_beneficiary"`
	AccountNumber     sql.NullString    `json:"account_number"`
	NameOfBank        sql.NullString    `json:"name_of_bank"`
	IfscCode          sql.NullString    `json:"ifsc_code"`
	Amount            string            `json:"amount"`
	Purpose           sql.NullString    `json:"purpose"`
	Status            NullPaymentStatus `json:"status"`
}

func (q *Queries) UpdatePayment(ctx context.Context, arg UpdatePaymentParams) (Payment, error) {
	row := q.db.QueryRowContext(ctx, updatePayment,
		arg.ID,
		arg.TemplateType,
		arg.Project,
		arg.AccountFullName,
		arg.FromAccountType,
		arg.FullAccountNumber,
		arg.ToAccount,
		arg.ToAccountType,
		arg.NameOfBeneficiary,
		arg.AccountNumber,
		arg.NameOfBank,
		arg.IfscCode,
		arg.Amount,
		arg.Purpose,
		arg.Status,
	)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.SlNo,
		&i.TemplateType,
		&i.Project,
		&i.AccountFullName,
		&i.FromAccountType,
		&i.FullAccountNumber,
		&i.ToAccount,
		&i.ToAccountType,
		&i.NameOfBeneficiary,
		&i.AccountNumber,
		&i.NameOfBank,
		&i.IfscCode,
		&i.Amount,
		&i.Purpose,
		&i.Status,
		&i.UserID,
		&i.PaymentNoteID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePaymentStatus = `-- name: UpdatePaymentStatus :exec
UPDATE payments
SET
    status = $2,
    updated_at = NOW()
WHERE sl_no = $1
`

type UpdatePaymentStatusParams struct {
	SlNo   string            `json:"sl_no"`
	Status NullPaymentStatus `json:"status"`
}

func (q *Queries) UpdatePaymentStatus(ctx context.Context, arg UpdatePaymentStatusParams) error {
	_, err := q.db.ExecContext(ctx, updatePaymentStatus, arg.SlNo, arg.Status)
	return err
}
