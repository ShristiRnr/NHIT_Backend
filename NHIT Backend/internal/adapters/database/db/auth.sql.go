// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: auth.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const assignRolesToUserBulk = `-- name: AssignRolesToUserBulk :exec
INSERT INTO user_roles (user_id, role_id)
SELECT $1 AS user_id, unnest($2::uuid[]) AS role_id
ON CONFLICT (user_id, role_id) DO NOTHING
`

type AssignRolesToUserBulkParams struct {
	UserID  uuid.UUID
	Column2 []uuid.UUID
}

func (q *Queries) AssignRolesToUserBulk(ctx context.Context, arg AssignRolesToUserBulkParams) error {
	_, err := q.db.ExecContext(ctx, assignRolesToUserBulk, arg.UserID, pq.Array(arg.Column2))
	return err
}

const checkEmailVerificationToken = `-- name: CheckEmailVerificationToken :one
SELECT token, user_id, expires_at, created_at
FROM email_verification_tokens
WHERE user_id = $1 AND token = $2 AND expires_at > NOW()
`

type CheckEmailVerificationTokenParams struct {
	UserID uuid.UUID
	Token  uuid.UUID
}

func (q *Queries) CheckEmailVerificationToken(ctx context.Context, arg CheckEmailVerificationTokenParams) (EmailVerificationToken, error) {
	row := q.db.QueryRowContext(ctx, checkEmailVerificationToken, arg.UserID, arg.Token)
	var i EmailVerificationToken
	err := row.Scan(
		&i.Token,
		&i.UserID,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const createEmailVerificationToken = `-- name: CreateEmailVerificationToken :one
INSERT INTO email_verification_tokens (user_id, expires_at)
VALUES ($1, $2)
RETURNING token, user_id, expires_at, created_at
`

type CreateEmailVerificationTokenParams struct {
	UserID    uuid.UUID
	ExpiresAt time.Time
}

// Email Verification
func (q *Queries) CreateEmailVerificationToken(ctx context.Context, arg CreateEmailVerificationTokenParams) (EmailVerificationToken, error) {
	row := q.db.QueryRowContext(ctx, createEmailVerificationToken, arg.UserID, arg.ExpiresAt)
	var i EmailVerificationToken
	err := row.Scan(
		&i.Token,
		&i.UserID,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const createPasswordResetToken = `-- name: CreatePasswordResetToken :one
INSERT INTO password_resets (user_id, token, expires_at)
VALUES ($1, $2, $3)
RETURNING token
`

type CreatePasswordResetTokenParams struct {
	UserID    uuid.UUID
	Token     uuid.UUID
	ExpiresAt time.Time
}

// Password Reset
func (q *Queries) CreatePasswordResetToken(ctx context.Context, arg CreatePasswordResetTokenParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, createPasswordResetToken, arg.UserID, arg.Token, arg.ExpiresAt)
	var token uuid.UUID
	err := row.Scan(&token)
	return token, err
}

const createRefreshToken = `-- name: CreateRefreshToken :exec
INSERT INTO refresh_tokens (token, user_id, expires_at)
VALUES ($1, $2, $3)
`

type CreateRefreshTokenParams struct {
	Token     string
	UserID    uuid.NullUUID
	ExpiresAt time.Time
}

// Refresh Tokens
func (q *Queries) CreateRefreshToken(ctx context.Context, arg CreateRefreshTokenParams) error {
	_, err := q.db.ExecContext(ctx, createRefreshToken, arg.Token, arg.UserID, arg.ExpiresAt)
	return err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (tenant_id, name, email, password)
VALUES ($1, $2, $3, $4)
RETURNING user_id, tenant_id, name, email, password, email_verified_at, last_login_at, last_logout_at, last_login_ip, user_agent, created_at, updated_at, department_id, designation_id
`

type CreateUserParams struct {
	TenantID uuid.UUID
	Name     string
	Email    string
	Password string
}

// Registration
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.TenantID,
		arg.Name,
		arg.Email,
		arg.Password,
	)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.TenantID,
		&i.Name,
		&i.Email,
		&i.Password,
		&i.EmailVerifiedAt,
		&i.LastLoginAt,
		&i.LastLogoutAt,
		&i.LastLoginIp,
		&i.UserAgent,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DepartmentID,
		&i.DesignationID,
	)
	return i, err
}

const deleteEmailVerificationTokensByUser = `-- name: DeleteEmailVerificationTokensByUser :exec
DELETE FROM email_verification_tokens
WHERE user_id = $1
`

func (q *Queries) DeleteEmailVerificationTokensByUser(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteEmailVerificationTokensByUser, userID)
	return err
}

const deletePasswordResetToken = `-- name: DeletePasswordResetToken :exec
DELETE FROM password_resets
WHERE token = $1
`

func (q *Queries) DeletePasswordResetToken(ctx context.Context, token uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deletePasswordResetToken, token)
	return err
}

const deleteRefreshToken = `-- name: DeleteRefreshToken :exec
DELETE FROM refresh_tokens
WHERE token = $1
`

func (q *Queries) DeleteRefreshToken(ctx context.Context, token string) error {
	_, err := q.db.ExecContext(ctx, deleteRefreshToken, token)
	return err
}

const deleteRolesForUser = `-- name: DeleteRolesForUser :exec
DELETE FROM user_roles
WHERE user_id = $1
`

func (q *Queries) DeleteRolesForUser(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteRolesForUser, userID)
	return err
}

const getPasswordResetToken = `-- name: GetPasswordResetToken :one
SELECT token, user_id, expires_at, created_at
FROM password_resets
WHERE token = $1 AND expires_at > NOW()
`

func (q *Queries) GetPasswordResetToken(ctx context.Context, token uuid.UUID) (PasswordReset, error) {
	row := q.db.QueryRowContext(ctx, getPasswordResetToken, token)
	var i PasswordReset
	err := row.Scan(
		&i.Token,
		&i.UserID,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getUserByEmailAndTenant = `-- name: GetUserByEmailAndTenant :one
SELECT user_id, tenant_id, name, email, password, email_verified_at, last_login_at, last_logout_at, last_login_ip, user_agent, created_at, updated_at, department_id, designation_id
FROM users
WHERE tenant_id = $1 AND email = $2
`

type GetUserByEmailAndTenantParams struct {
	TenantID uuid.UUID
	Email    string
}

func (q *Queries) GetUserByEmailAndTenant(ctx context.Context, arg GetUserByEmailAndTenantParams) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmailAndTenant, arg.TenantID, arg.Email)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.TenantID,
		&i.Name,
		&i.Email,
		&i.Password,
		&i.EmailVerifiedAt,
		&i.LastLoginAt,
		&i.LastLogoutAt,
		&i.LastLoginIp,
		&i.UserAgent,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DepartmentID,
		&i.DesignationID,
	)
	return i, err
}

const getUserByEmailTenantAndOrg = `-- name: GetUserByEmailTenantAndOrg :one
SELECT u.user_id, u.tenant_id, u.name, u.email, u.password, u.email_verified_at, u.last_login_at, u.last_logout_at, u.last_login_ip, u.user_agent, u.created_at, u.updated_at, u.department_id, u.designation_id
FROM users u
JOIN user_organizations uo ON uo.user_id = u.user_id
WHERE u.tenant_id = $1 AND uo.org_id = $2 AND u.email = $3
`

type GetUserByEmailTenantAndOrgParams struct {
	TenantID uuid.UUID
	OrgID    uuid.UUID
	Email    string
}

// Optional org-scoped fetch for login flows where org must be enforced
func (q *Queries) GetUserByEmailTenantAndOrg(ctx context.Context, arg GetUserByEmailTenantAndOrgParams) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmailTenantAndOrg, arg.TenantID, arg.OrgID, arg.Email)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.TenantID,
		&i.Name,
		&i.Email,
		&i.Password,
		&i.EmailVerifiedAt,
		&i.LastLoginAt,
		&i.LastLogoutAt,
		&i.LastLoginIp,
		&i.UserAgent,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DepartmentID,
		&i.DesignationID,
	)
	return i, err
}

const getUserIDByRefreshToken = `-- name: GetUserIDByRefreshToken :one
SELECT user_id
FROM refresh_tokens
WHERE token = $1 AND expires_at > NOW()
`

func (q *Queries) GetUserIDByRefreshToken(ctx context.Context, token string) (uuid.NullUUID, error) {
	row := q.db.QueryRowContext(ctx, getUserIDByRefreshToken, token)
	var user_id uuid.NullUUID
	err := row.Scan(&user_id)
	return user_id, err
}

const isUserInOrganization = `-- name: IsUserInOrganization :one
SELECT EXISTS (
  SELECT 1
  FROM user_organizations
  WHERE user_id = $1 AND org_id = $2
) AS exists
`

type IsUserInOrganizationParams struct {
	UserID uuid.UUID
	OrgID  uuid.UUID
}

// Org membership check
func (q *Queries) IsUserInOrganization(ctx context.Context, arg IsUserInOrganizationParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, isUserInOrganization, arg.UserID, arg.OrgID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const listRoleIDsByNamesForTenant = `-- name: ListRoleIDsByNamesForTenant :many
SELECT role_id
FROM roles
WHERE tenant_id = $1 AND name = ANY($2::text[])
`

type ListRoleIDsByNamesForTenantParams struct {
	TenantID uuid.UUID
	Column2  []string
}

// Role assignment helpers for registration/updates
func (q *Queries) ListRoleIDsByNamesForTenant(ctx context.Context, arg ListRoleIDsByNamesForTenantParams) ([]uuid.UUID, error) {
	rows, err := q.db.QueryContext(ctx, listRoleIDsByNamesForTenant, arg.TenantID, pq.Array(arg.Column2))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uuid.UUID
	for rows.Next() {
		var role_id uuid.UUID
		if err := rows.Scan(&role_id); err != nil {
			return nil, err
		}
		items = append(items, role_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserPermissionNames = `-- name: ListUserPermissionNames :many
SELECT p.name
FROM permissions p
JOIN role_permissions rp ON rp.permission_id = p.permission_id
JOIN user_roles ur ON ur.role_id = rp.role_id
WHERE ur.user_id = $1
ORDER BY p.name
`

func (q *Queries) ListUserPermissionNames(ctx context.Context, userID uuid.UUID) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listUserPermissionNames, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserRoleNames = `-- name: ListUserRoleNames :many
SELECT r.name
FROM roles r
JOIN user_roles ur ON ur.role_id = r.role_id
WHERE ur.user_id = $1
ORDER BY r.name
`

// Roles & Permissions for response enrichment
func (q *Queries) ListUserRoleNames(ctx context.Context, userID uuid.UUID) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listUserRoleNames, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const recordUserLogin = `-- name: RecordUserLogin :one
INSERT INTO user_login_history (user_id, ip_address, user_agent)
VALUES ($1, $2, $3)
RETURNING history_id, user_id, ip_address, user_agent, login_time
`

type RecordUserLoginParams struct {
	UserID    uuid.NullUUID
	IpAddress sql.NullString
	UserAgent sql.NullString
}

// Login / Logout helpers
func (q *Queries) RecordUserLogin(ctx context.Context, arg RecordUserLoginParams) (UserLoginHistory, error) {
	row := q.db.QueryRowContext(ctx, recordUserLogin, arg.UserID, arg.IpAddress, arg.UserAgent)
	var i UserLoginHistory
	err := row.Scan(
		&i.HistoryID,
		&i.UserID,
		&i.IpAddress,
		&i.UserAgent,
		&i.LoginTime,
	)
	return i, err
}

const updateUserLastLogin = `-- name: UpdateUserLastLogin :exec
UPDATE users
SET last_login_at = NOW(), last_login_ip = $2, user_agent = $3, updated_at = NOW()
WHERE user_id = $1
`

type UpdateUserLastLoginParams struct {
	UserID      uuid.UUID
	LastLoginIp sql.NullString
	UserAgent   sql.NullString
}

func (q *Queries) UpdateUserLastLogin(ctx context.Context, arg UpdateUserLastLoginParams) error {
	_, err := q.db.ExecContext(ctx, updateUserLastLogin, arg.UserID, arg.LastLoginIp, arg.UserAgent)
	return err
}

const updateUserLastLogout = `-- name: UpdateUserLastLogout :exec
UPDATE users
SET last_logout_at = NOW(), updated_at = NOW()
WHERE user_id = $1
`

func (q *Queries) UpdateUserLastLogout(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, updateUserLastLogout, userID)
	return err
}

const updateUserPassword = `-- name: UpdateUserPassword :exec
UPDATE users
SET password = $2, updated_at = NOW()
WHERE user_id = $1
`

type UpdateUserPasswordParams struct {
	UserID   uuid.UUID
	Password string
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) error {
	_, err := q.db.ExecContext(ctx, updateUserPassword, arg.UserID, arg.Password)
	return err
}

const verifyUserEmail = `-- name: VerifyUserEmail :exec
UPDATE users
SET email_verified_at = NOW(), updated_at = NOW()
WHERE user_id = $1
`

func (q *Queries) VerifyUserEmail(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, verifyUserEmail, userID)
	return err
}
