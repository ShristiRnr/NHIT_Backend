package handlers

import (
	"context"
	"fmt"
	"regexp"
	"strings"
	"time"

	vendorpb "github.com/ShristiRnr/NHIT_Backend/api/pb/vendorpb"
	"github.com/google/uuid"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/types/known/emptypb"
	"google.golang.org/protobuf/types/known/timestamppb"
)

// VendorHandler implements the complete VendorService with production-level business logic
type VendorHandler struct {
	vendorpb.UnimplementedVendorServiceServer
}

// NewVendorHandler creates a new production-ready vendor handler
func NewVendorHandler() *VendorHandler {
	return &VendorHandler{}
}

// Mock data store (in production, this would be a database)
var (
	vendors = make(map[string]*vendorpb.Vendor)
	accounts = make(map[string]*vendorpb.VendorAccount)
	vendorAccounts = make(map[string][]*vendorpb.VendorAccount) // vendorId -> accounts
)

// CreateVendor creates a new vendor with strong business validation
func (h *VendorHandler) CreateVendor(ctx context.Context, req *vendorpb.CreateVendorRequest) (*vendorpb.VendorResponse, error) {
	// Validate required fields
	if err := h.validateCreateVendorRequest(req); err != nil {
		return nil, err
	}

	// Generate vendor ID and code
	vendorID := uuid.New().String()
	vendorCode := h.generateVendorCode(req.VendorName, req.VendorType)

	// Check for duplicates
	if h.isVendorEmailExists(req.VendorEmail) {
		return nil, status.Error(codes.AlreadyExists, "vendor email already exists")
	}
	if h.isVendorCodeExists(vendorCode) {
		vendorCode = fmt.Sprintf("%s-%d", vendorCode, time.Now().Unix()%1000)
	}

	// Create vendor
	vendor := &vendorpb.Vendor{
		Id:                    vendorID,
		TenantId:              req.TenantId,
		VendorCode:            vendorCode,
		VendorName:            req.VendorName,
		VendorEmail:           req.VendorEmail,
		VendorMobile:          req.VendorMobile,
		VendorType:            req.VendorType,
		VendorNickName:        req.VendorNickName,
		ActivityType:          req.ActivityType,
		Email:                 req.Email,
		Mobile:                req.Mobile,
		Gstin:                 req.Gstin,
		Pan:                   req.Pan,
		Pin:                   req.Pin,
		CountryId:             req.CountryId,
		StateId:               req.StateId,
		CityId:                req.CityId,
		CountryName:           req.CountryName,
		StateName:             req.StateName,
		CityName:              req.CityName,
		MsmeClassification:    req.MsmeClassification,
		Msme:                  req.Msme,
		MsmeRegistrationNumber: req.MsmeRegistrationNumber,
		MaterialNature:        req.MaterialNature,
		GstDefaulted:          req.GstDefaulted,
		Section_206AbVerified: req.Section_206AbVerified,
		BeneficiaryName:       req.BeneficiaryName,
		RemarksAddress:        req.RemarksAddress,
		CommonBankDetails:     req.CommonBankDetails,
		IncomeTaxType:         req.IncomeTaxType,
		Project:               req.Project,
		Status:                req.Status,
		FromAccountType:       req.FromAccountType,
		AccountName:           req.AccountName,
		ShortName:             req.ShortName,
		Parent:                req.Parent,
		FilePaths:             req.FilePaths,
		CodeAutoGenerated:     true,
		IsActive:              true,
		CreatedBy:             req.CreatedBy,
		CreatedAt:             timestamppb.Now(),
		UpdatedAt:             timestamppb.Now(),
		AccountNumber:         req.AccountNumber,
		NameOfBank:            req.NameOfBank,
		IfscCode:              req.IfscCode,
		IfscCodeId:            req.IfscCodeId,
	}

	// Handle MSME dates
	if req.MsmeStartDate != nil && *req.MsmeStartDate != "" {
		if startDate, err := time.Parse("2006-01-02", *req.MsmeStartDate); err == nil {
			vendor.MsmeStartDate = timestamppb.New(startDate)
		}
	}
	if req.MsmeEndDate != nil && *req.MsmeEndDate != "" {
		if endDate, err := time.Parse("2006-01-02", *req.MsmeEndDate); err == nil {
			vendor.MsmeEndDate = timestamppb.New(endDate)
		}
	}

	// Store vendor
	vendors[vendorID] = vendor

	// Create primary account if banking details provided
	if req.AccountNumber != nil && req.NameOfBank != nil && req.IfscCode != nil {
		accountReq := &vendorpb.CreateVendorAccountRequest{
			VendorId:      vendorID,
			AccountName:   vendor.VendorName,
			AccountNumber: *req.AccountNumber,
			NameOfBank:    *req.NameOfBank,
			IfscCode:      *req.IfscCode,
			IsPrimary:     true,
			CreatedBy:     req.CreatedBy,
		}
		h.CreateVendorAccount(ctx, accountReq)
	}

	return &vendorpb.VendorResponse{Vendor: vendor}, nil
}

// GetVendor retrieves a vendor by ID
func (h *VendorHandler) GetVendor(ctx context.Context, req *vendorpb.GetVendorRequest) (*vendorpb.VendorResponse, error) {
	if req.TenantId == "" || req.VendorId == "" {
		return nil, status.Error(codes.InvalidArgument, "tenant_id and vendor_id are required")
	}

	vendor, exists := vendors[req.VendorId]
	if !exists || vendor.TenantId != req.TenantId {
		return nil, status.Error(codes.NotFound, "vendor not found")
	}

	return &vendorpb.VendorResponse{Vendor: vendor}, nil
}

// GetVendorByCode retrieves a vendor by code
func (h *VendorHandler) GetVendorByCode(ctx context.Context, req *vendorpb.GetVendorByCodeRequest) (*vendorpb.VendorResponse, error) {
	if req.TenantId == "" || req.VendorCode == "" {
		return nil, status.Error(codes.InvalidArgument, "tenant_id and vendor_code are required")
	}

	for _, vendor := range vendors {
		if vendor.TenantId == req.TenantId && vendor.VendorCode == req.VendorCode {
			return &vendorpb.VendorResponse{Vendor: vendor}, nil
		}
	}

	return nil, status.Error(codes.NotFound, "vendor not found")
}

// UpdateVendor updates an existing vendor
func (h *VendorHandler) UpdateVendor(ctx context.Context, req *vendorpb.UpdateVendorRequest) (*vendorpb.VendorResponse, error) {
	if req.TenantId == "" || req.VendorId == "" {
		return nil, status.Error(codes.InvalidArgument, "tenant_id and vendor_id are required")
	}

	vendor, exists := vendors[req.VendorId]
	if !exists || vendor.TenantId != req.TenantId {
		return nil, status.Error(codes.NotFound, "vendor not found")
	}

	// Update fields if provided
	if req.VendorName != nil {
		if err := h.validateVendorName(*req.VendorName); err != nil {
			return nil, err
		}
		vendor.VendorName = *req.VendorName
	}
	if req.VendorEmail != nil {
		if err := h.validateEmail(*req.VendorEmail); err != nil {
			return nil, err
		}
		if h.isVendorEmailExistsExcluding(*req.VendorEmail, req.VendorId) {
			return nil, status.Error(codes.AlreadyExists, "vendor email already exists")
		}
		vendor.VendorEmail = *req.VendorEmail
	}
	if req.VendorMobile != nil {
		vendor.VendorMobile = req.VendorMobile
	}
	if req.Pan != nil {
		if err := h.validatePAN(*req.Pan); err != nil {
			return nil, err
		}
		vendor.Pan = *req.Pan
	}
	if req.BeneficiaryName != nil {
		vendor.BeneficiaryName = *req.BeneficiaryName
	}
	if req.IsActive != nil {
		vendor.IsActive = *req.IsActive
	}

	vendor.UpdatedAt = timestamppb.Now()
	vendors[req.VendorId] = vendor

	return &vendorpb.VendorResponse{Vendor: vendor}, nil
}

// DeleteVendor deletes a vendor
func (h *VendorHandler) DeleteVendor(ctx context.Context, req *vendorpb.DeleteVendorRequest) (*emptypb.Empty, error) {
	if req.TenantId == "" || req.VendorId == "" {
		return nil, status.Error(codes.InvalidArgument, "tenant_id and vendor_id are required")
	}

	vendor, exists := vendors[req.VendorId]
	if !exists || vendor.TenantId != req.TenantId {
		return nil, status.Error(codes.NotFound, "vendor not found")
	}

	// Delete vendor and associated accounts
	delete(vendors, req.VendorId)
	if vendorAccountsList, exists := vendorAccounts[req.VendorId]; exists {
		for _, account := range vendorAccountsList {
			delete(accounts, account.Id)
		}
		delete(vendorAccounts, req.VendorId)
	}

	return &emptypb.Empty{}, nil
}

// ListVendors lists vendors with filtering and pagination
func (h *VendorHandler) ListVendors(ctx context.Context, req *vendorpb.ListVendorsRequest) (*vendorpb.ListVendorsResponse, error) {
	if req.TenantId == "" {
		return nil, status.Error(codes.InvalidArgument, "tenant_id is required")
	}

	var filteredVendors []*vendorpb.Vendor
	for _, vendor := range vendors {
		if vendor.TenantId != req.TenantId {
			continue
		}

		// Apply filters
		if req.IsActive != nil && vendor.IsActive != *req.IsActive {
			continue
		}
		if req.VendorType != nil && vendor.VendorType != req.VendorType {
			continue
		}
		if req.Project != nil && vendor.Project != req.Project {
			continue
		}
		if req.Search != nil && *req.Search != "" {
			searchTerm := strings.ToLower(*req.Search)
			if !strings.Contains(strings.ToLower(vendor.VendorName), searchTerm) &&
				!strings.Contains(strings.ToLower(vendor.VendorEmail), searchTerm) &&
				!strings.Contains(strings.ToLower(vendor.VendorCode), searchTerm) {
				continue
			}
		}

		filteredVendors = append(filteredVendors, vendor)
	}

	// Apply pagination
	total := int64(len(filteredVendors))
	start := int(req.Offset)
	end := start + int(req.Limit)
	if start > len(filteredVendors) {
		start = len(filteredVendors)
	}
	if end > len(filteredVendors) {
		end = len(filteredVendors)
	}

	paginatedVendors := filteredVendors[start:end]

	return &vendorpb.ListVendorsResponse{
		Vendors:    paginatedVendors,
		TotalCount: total,
	}, nil
}

// GenerateVendorCode generates a vendor code
func (h *VendorHandler) GenerateVendorCode(ctx context.Context, req *vendorpb.GenerateVendorCodeRequest) (*vendorpb.GenerateVendorCodeResponse, error) {
	if req.VendorName == "" {
		return nil, status.Error(codes.InvalidArgument, "vendor_name is required")
	}

	code := h.generateVendorCode(req.VendorName, req.VendorType)
	
	return &vendorpb.GenerateVendorCodeResponse{
		VendorCode: code,
	}, nil
}

// UpdateVendorCode updates vendor code
func (h *VendorHandler) UpdateVendorCode(ctx context.Context, req *vendorpb.UpdateVendorCodeRequest) (*vendorpb.VendorResponse, error) {
	if req.TenantId == "" || req.VendorId == "" || req.VendorCode == "" {
		return nil, status.Error(codes.InvalidArgument, "tenant_id, vendor_id, and vendor_code are required")
	}

	vendor, exists := vendors[req.VendorId]
	if !exists || vendor.TenantId != req.TenantId {
		return nil, status.Error(codes.NotFound, "vendor not found")
	}

	if h.isVendorCodeExistsExcluding(req.VendorCode, req.VendorId) {
		return nil, status.Error(codes.AlreadyExists, "vendor code already exists")
	}

	vendor.VendorCode = req.VendorCode
	vendor.CodeAutoGenerated = false
	vendor.UpdatedAt = timestamppb.Now()
	vendors[req.VendorId] = vendor

	return &vendorpb.VendorResponse{Vendor: vendor}, nil
}

// RegenerateVendorCode regenerates vendor code
func (h *VendorHandler) RegenerateVendorCode(ctx context.Context, req *vendorpb.RegenerateVendorCodeRequest) (*vendorpb.VendorResponse, error) {
	if req.TenantId == "" || req.VendorId == "" {
		return nil, status.Error(codes.InvalidArgument, "tenant_id and vendor_id are required")
	}

	vendor, exists := vendors[req.VendorId]
	if !exists || vendor.TenantId != req.TenantId {
		return nil, status.Error(codes.NotFound, "vendor not found")
	}

	newCode := h.generateVendorCode(vendor.VendorName, vendor.VendorType)
	if h.isVendorCodeExistsExcluding(newCode, req.VendorId) {
		newCode = fmt.Sprintf("%s-%d", newCode, time.Now().Unix()%1000)
	}

	vendor.VendorCode = newCode
	vendor.CodeAutoGenerated = true
	vendor.UpdatedAt = timestamppb.Now()
	vendors[req.VendorId] = vendor

	return &vendorpb.VendorResponse{Vendor: vendor}, nil
}

// CreateVendorAccount creates a new vendor account
func (h *VendorHandler) CreateVendorAccount(ctx context.Context, req *vendorpb.CreateVendorAccountRequest) (*vendorpb.VendorAccountResponse, error) {
	if err := h.validateCreateAccountRequest(req); err != nil {
		return nil, err
	}

	// Check if vendor exists
	_, exists := vendors[req.VendorId]
	if !exists {
		return nil, status.Error(codes.NotFound, "vendor not found")
	}

	accountID := uuid.New().String()

	// If setting as primary, unset other primary accounts
	if req.IsPrimary {
		if vendorAccountsList, exists := vendorAccounts[req.VendorId]; exists {
			for _, account := range vendorAccountsList {
				account.IsPrimary = false
				accounts[account.Id] = account
			}
		}
	}

	account := &vendorpb.VendorAccount{
		Id:            accountID,
		VendorId:      req.VendorId,
		AccountName:   req.AccountName,
		AccountNumber: req.AccountNumber,
		NameOfBank:    req.NameOfBank,
		BranchName:    req.BranchName,
		IfscCode:      req.IfscCode,
		SwiftCode:     req.SwiftCode,
		IsPrimary:     req.IsPrimary,
		IsActive:      true,
		CreatedBy:     req.CreatedBy,
		CreatedAt:     timestamppb.Now(),
		UpdatedAt:     timestamppb.Now(),
	}

	// Store account
	accounts[accountID] = account
	vendorAccounts[req.VendorId] = append(vendorAccounts[req.VendorId], account)

	return &vendorpb.VendorAccountResponse{Account: account}, nil
}

// GetVendorAccounts gets all accounts for a vendor
func (h *VendorHandler) GetVendorAccounts(ctx context.Context, req *vendorpb.GetVendorAccountsRequest) (*vendorpb.GetVendorAccountsResponse, error) {
	if req.VendorId == "" {
		return nil, status.Error(codes.InvalidArgument, "vendor_id is required")
	}

	vendorAccountsList, exists := vendorAccounts[req.VendorId]
	if !exists {
		vendorAccountsList = []*vendorpb.VendorAccount{}
	}

	return &vendorpb.GetVendorAccountsResponse{
		Accounts: vendorAccountsList,
	}, nil
}

// GetVendorBankingDetails gets banking details for payment processing
func (h *VendorHandler) GetVendorBankingDetails(ctx context.Context, req *vendorpb.GetVendorBankingDetailsRequest) (*vendorpb.BankingDetailsResponse, error) {
	if req.VendorId == "" {
		return nil, status.Error(codes.InvalidArgument, "vendor_id is required")
	}

	var account *vendorpb.VendorAccount

	if req.AccountId != nil && *req.AccountId != "" {
		// Get specific account
		if acc, exists := accounts[*req.AccountId]; exists && acc.VendorId == req.VendorId {
			account = acc
		}
	} else {
		// Get primary account
		if vendorAccountsList, exists := vendorAccounts[req.VendorId]; exists {
			for _, acc := range vendorAccountsList {
				if acc.IsPrimary && acc.IsActive {
					account = acc
					break
				}
			}
		}
	}

	if account == nil {
		return nil, status.Error(codes.NotFound, "banking details not found")
	}

	return &vendorpb.BankingDetailsResponse{
		BankingDetails: &vendorpb.BankingDetails{
			AccountName:   account.AccountName,
			AccountNumber: account.AccountNumber,
			NameOfBank:    account.NameOfBank,
			BranchName:    account.BranchName,
			IfscCode:      account.IfscCode,
			SwiftCode:     account.SwiftCode,
		},
	}, nil
}

// UpdateVendorAccount updates a vendor account
func (h *VendorHandler) UpdateVendorAccount(ctx context.Context, req *vendorpb.UpdateVendorAccountRequest) (*vendorpb.VendorAccountResponse, error) {
	if req.AccountId == "" {
		return nil, status.Error(codes.InvalidArgument, "account_id is required")
	}

	account, exists := accounts[req.AccountId]
	if !exists {
		return nil, status.Error(codes.NotFound, "account not found")
	}

	// Update fields if provided
	if req.AccountName != nil {
		account.AccountName = *req.AccountName
	}
	if req.AccountNumber != nil {
		account.AccountNumber = *req.AccountNumber
	}
	if req.NameOfBank != nil {
		account.NameOfBank = *req.NameOfBank
	}
	if req.BranchName != nil {
		account.BranchName = req.BranchName
	}
	if req.IfscCode != nil {
		if err := h.validateIFSC(*req.IfscCode); err != nil {
			return nil, err
		}
		account.IfscCode = *req.IfscCode
	}
	if req.SwiftCode != nil {
		account.SwiftCode = req.SwiftCode
	}
	if req.IsPrimary != nil && *req.IsPrimary && !account.IsPrimary {
		// Unset other primary accounts
		if vendorAccountsList, exists := vendorAccounts[account.VendorId]; exists {
			for _, acc := range vendorAccountsList {
				if acc.Id != account.Id {
					acc.IsPrimary = false
					accounts[acc.Id] = acc
				}
			}
		}
		account.IsPrimary = true
	}
	if req.IsActive != nil {
		account.IsActive = *req.IsActive
	}

	account.UpdatedAt = timestamppb.Now()
	accounts[req.AccountId] = account

	return &vendorpb.VendorAccountResponse{Account: account}, nil
}

// DeleteVendorAccount deletes a vendor account
func (h *VendorHandler) DeleteVendorAccount(ctx context.Context, req *vendorpb.DeleteVendorAccountRequest) (*emptypb.Empty, error) {
	if req.AccountId == "" {
		return nil, status.Error(codes.InvalidArgument, "account_id is required")
	}

	account, exists := accounts[req.AccountId]
	if !exists {
		return nil, status.Error(codes.NotFound, "account not found")
	}

	vendorId := account.VendorId
	wasPrimary := account.IsPrimary

	// Remove from accounts
	delete(accounts, req.AccountId)

	// Remove from vendor accounts list
	if vendorAccountsList, exists := vendorAccounts[vendorId]; exists {
		var updatedList []*vendorpb.VendorAccount
		for _, acc := range vendorAccountsList {
			if acc.Id != req.AccountId {
				updatedList = append(updatedList, acc)
			}
		}
		vendorAccounts[vendorId] = updatedList

		// If deleted account was primary, set another as primary
		if wasPrimary && len(updatedList) > 0 {
			updatedList[0].IsPrimary = true
			accounts[updatedList[0].Id] = updatedList[0]
		}
	}

	return &emptypb.Empty{}, nil
}

// ToggleAccountStatus toggles account active status
func (h *VendorHandler) ToggleAccountStatus(ctx context.Context, req *vendorpb.ToggleAccountStatusRequest) (*vendorpb.VendorAccountResponse, error) {
	if req.AccountId == "" {
		return nil, status.Error(codes.InvalidArgument, "account_id is required")
	}

	account, exists := accounts[req.AccountId]
	if !exists {
		return nil, status.Error(codes.NotFound, "account not found")
	}

	wasPrimary := account.IsPrimary
	account.IsActive = !account.IsActive

	// If deactivating a primary account, set another as primary
	if !account.IsActive && wasPrimary {
		if vendorAccountsList, exists := vendorAccounts[account.VendorId]; exists {
			for _, acc := range vendorAccountsList {
				if acc.Id != account.Id && acc.IsActive {
					acc.IsPrimary = true
					accounts[acc.Id] = acc
					break
				}
			}
		}
		account.IsPrimary = false
	}

	account.UpdatedAt = timestamppb.Now()
	accounts[req.AccountId] = account

	return &vendorpb.VendorAccountResponse{Account: account}, nil
}

// Validation methods
func (h *VendorHandler) validateCreateVendorRequest(req *vendorpb.CreateVendorRequest) error {
	if req.TenantId == "" {
		return status.Error(codes.InvalidArgument, "tenant_id is required")
	}
	if req.VendorName == "" {
		return status.Error(codes.InvalidArgument, "vendor_name is required")
	}
	if req.VendorEmail == "" {
		return status.Error(codes.InvalidArgument, "vendor_email is required")
	}
	if req.Pan == "" {
		return status.Error(codes.InvalidArgument, "pan is required")
	}
	if req.BeneficiaryName == "" {
		return status.Error(codes.InvalidArgument, "beneficiary_name is required")
	}
	if req.CreatedBy == "" {
		return status.Error(codes.InvalidArgument, "created_by is required")
	}

	if err := h.validateEmail(req.VendorEmail); err != nil {
		return err
	}
	if err := h.validatePAN(req.Pan); err != nil {
		return err
	}
	if req.IfscCode != nil {
		if err := h.validateIFSC(*req.IfscCode); err != nil {
			return err
		}
	}

	return nil
}

func (h *VendorHandler) validateCreateAccountRequest(req *vendorpb.CreateVendorAccountRequest) error {
	if req.VendorId == "" {
		return status.Error(codes.InvalidArgument, "vendor_id is required")
	}
	if req.AccountName == "" {
		return status.Error(codes.InvalidArgument, "account_name is required")
	}
	if req.AccountNumber == "" {
		return status.Error(codes.InvalidArgument, "account_number is required")
	}
	if req.NameOfBank == "" {
		return status.Error(codes.InvalidArgument, "name_of_bank is required")
	}
	if req.IfscCode == "" {
		return status.Error(codes.InvalidArgument, "ifsc_code is required")
	}
	if req.CreatedBy == "" {
		return status.Error(codes.InvalidArgument, "created_by is required")
	}

	return h.validateIFSC(req.IfscCode)
}

func (h *VendorHandler) validateEmail(email string) error {
	emailRegex := regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`)
	if !emailRegex.MatchString(email) {
		return status.Error(codes.InvalidArgument, "invalid email format")
	}
	return nil
}

func (h *VendorHandler) validatePAN(pan string) error {
	panRegex := regexp.MustCompile(`^[A-Z]{5}[0-9]{4}[A-Z]{1}$`)
	if !panRegex.MatchString(pan) {
		return status.Error(codes.InvalidArgument, "invalid PAN format")
	}
	return nil
}

func (h *VendorHandler) validateIFSC(ifsc string) error {
	ifscRegex := regexp.MustCompile(`^[A-Z]{4}0[A-Z0-9]{6}$`)
	if !ifscRegex.MatchString(ifsc) {
		return status.Error(codes.InvalidArgument, "invalid IFSC code format")
	}
	return nil
}

func (h *VendorHandler) validateVendorName(name string) error {
	if len(strings.TrimSpace(name)) < 2 {
		return status.Error(codes.InvalidArgument, "vendor name must be at least 2 characters")
	}
	return nil
}

// Business logic methods
func (h *VendorHandler) generateVendorCode(vendorName string, vendorType *string) string {
	// Clean vendor name
	name := strings.TrimSpace(vendorName)
	name = regexp.MustCompile(`[^a-zA-Z0-9\s]`).ReplaceAllString(name, "")
	words := strings.Fields(name)
	
	var prefix string
	if len(words) > 0 {
		if len(words[0]) >= 3 {
			prefix = strings.ToUpper(words[0][:3])
		} else {
			prefix = strings.ToUpper(words[0])
		}
	} else {
		prefix = "VEN"
	}

	// Determine type prefix
	typePrefix := "GN" // General
	if vendorType != nil {
		switch strings.ToLower(*vendorType) {
		case "internal":
			typePrefix = "IN"
		case "external":
			typePrefix = "EX"
		}
	}

	// Generate timestamp suffix
	timestamp := time.Now().Format("060102") // YYMMDD

	return fmt.Sprintf("%s-%s-%s", typePrefix, prefix, timestamp)
}

func (h *VendorHandler) isVendorEmailExists(email string) bool {
	for _, vendor := range vendors {
		if vendor.VendorEmail == email {
			return true
		}
	}
	return false
}

func (h *VendorHandler) isVendorEmailExistsExcluding(email, excludeId string) bool {
	for id, vendor := range vendors {
		if id != excludeId && vendor.VendorEmail == email {
			return true
		}
	}
	return false
}

func (h *VendorHandler) isVendorCodeExists(code string) bool {
	for _, vendor := range vendors {
		if vendor.VendorCode == code {
			return true
		}
	}
	return false
}

func (h *VendorHandler) isVendorCodeExistsExcluding(code, excludeId string) bool {
	for id, vendor := range vendors {
		if id != excludeId && vendor.VendorCode == code {
			return true
		}
	}
	return false
}
