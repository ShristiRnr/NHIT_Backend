package repository

import (
	"context"
	"fmt"


	"github.com/ShristiRnr/NHIT_Backend/services/vendor-service/internal/adapters/repository/sqlc/generated"
	"github.com/ShristiRnr/NHIT_Backend/services/vendor-service/internal/core/domain"
	"github.com/ShristiRnr/NHIT_Backend/services/vendor-service/internal/core/ports"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/jackc/pgx/v5/pgxpool"
)

// vendorRepository implements22 ports.VendorRepository using SQLC
type vendorRepository struct {
	db      *pgxpool.Pool
	queries *sqlc.Queries
}

// NewVendorRepository creates a new vendor repository
func NewVendorRepository(pool *pgxpool.Pool) ports.VendorRepository {
	return &vendorRepository{
		db:      pool,
		queries: sqlc.New(pool),
	}
}

// CreateVendor creates a new vendor
func (r *vendorRepository) CreateVendor(ctx context.Context, vendor *domain.Vendor) error {
	// Convert domain vendor to SQLC params
	accountType := &vendor.AccountType
	// Handle Enums: Convert empty strings to nil for SQLC
	var msmeClass *string
	if vendor.MSMEClassification != "" && vendor.MSMEClassification != "MSME_CLASSIFICATION_UNSPECIFIED" {
		msmeClass = &vendor.MSMEClassification
	}

	status := &vendor.Status
	codeAuto := vendor.CodeAutoGenerated

	params := sqlc.CreateVendorParams{
		ID:                     vendor.ID,
		TenantID:               vendor.TenantID,
		VendorCode:             vendor.VendorCode,
		VendorName:             vendor.VendorName,
		VendorEmail:            vendor.VendorEmail,
		VendorMobile:           vendor.VendorMobile,
		VendorType:             accountType, // This maps to account_type column now
		VendorNickName:         vendor.VendorNickName,
		ActivityType:           vendor.ActivityType,
		Email:                  vendor.Email,
		Mobile:                 vendor.Mobile,
		Gstin:                  vendor.GSTIN,
		Pan:                    vendor.PAN,
		Pin:                    vendor.PIN,
		CountryID:              vendor.CountryID,
		StateID:                vendor.StateID,
		CityID:                 vendor.CityID,
		CountryName:            vendor.CountryName,
		StateName:              vendor.StateName,
		CityName:               vendor.CityName,
		MsmeClassification:     msmeClass,
		Msme:                   vendor.MSME,
		MsmeRegistrationNumber: vendor.MSMERegistrationNumber,
		MaterialNature:         vendor.MaterialNature,
		GstDefaulted:           vendor.GSTDefaulted,
		Section206abVerified:   vendor.Section206ABVerified,
		BeneficiaryName:        vendor.BeneficiaryName,
		RemarksAddress:         vendor.RemarksAddress,
		CommonBankDetails:      vendor.CommonBankDetails,
		IncomeTaxType:          vendor.IncomeTaxType,
		Project:                vendor.ProjectID,
		Status:                 status,
		FromAccountType:        vendor.FromAccountType,
		AccountName:            vendor.AccountName,
		ShortName:              vendor.ShortName,
		Parent:                 vendor.Parent,
		CodeAutoGenerated:      &codeAuto,
		CreatedBy:              vendor.CreatedBy,
		AccountNumber:          vendor.AccountNumber,
		NameOfBank:             vendor.NameOfBank,
		IfscCode:               vendor.IFSCCode,
		IfscCodeID:             vendor.IFSCCodeID,
	}

	return r.queries.CreateVendor(ctx, params)
}

// GetVendorByID retrieves a vendor by ID
func (r *vendorRepository) GetVendorByID(ctx context.Context, tenantID, vendorID uuid.UUID) (*domain.Vendor, error) {
	vendor, err := r.queries.GetVendorByID(ctx, sqlc.GetVendorByIDParams{
		ID:       vendorID,
		TenantID: tenantID,
	})
	if err != nil {
		if err == pgx.ErrNoRows {
			return nil, domain.ErrVendorNotFound
		}
		return nil, err
	}

	return toDomainVendor(vendor), nil
}

// GetVendorByCode retrieves a vendor by code
func (r *vendorRepository) GetVendorByCode(ctx context.Context, tenantID uuid.UUID, vendorCode string) (*domain.Vendor, error) {
	vendor, err := r.queries.GetVendorByCode(ctx, sqlc.GetVendorByCodeParams{
		VendorCode: vendorCode,
		TenantID:   tenantID,
	})
	if err != nil {
		if err == pgx.ErrNoRows {
			return nil, domain.ErrVendorNotFound
		}
		return nil, err
	}

	return toDomainVendor(vendor), nil
}

// GetVendorByEmail retrieves a vendor by email
func (r *vendorRepository) GetVendorByEmail(ctx context.Context, tenantID uuid.UUID, email string) (*domain.Vendor, error) {
	vendor, err := r.queries.GetVendorByEmail(ctx, sqlc.GetVendorByEmailParams{
		VendorEmail: email,
		TenantID:    tenantID,
	})
	if err != nil {
		if err == pgx.ErrNoRows {
			return nil, domain.ErrVendorNotFound
		}
		return nil, err
	}

	return toDomainVendor(vendor), nil
}

// UpdateVendor updates an existing vendor
func (r *vendorRepository) UpdateVendor(ctx context.Context, vendor *domain.Vendor) error {
	var msmeClass *string
	if vendor.MSMEClassification != "" && vendor.MSMEClassification != "MSME_CLASSIFICATION_UNSPECIFIED" {
		msmeClass = &vendor.MSMEClassification
	}

	isActive := (vendor.Status == "ACTIVE")

	params := sqlc.UpdateVendorParams{
		ID:                     vendor.ID,
		TenantID:               vendor.TenantID,
		VendorName:             vendor.VendorName,
		VendorEmail:            vendor.VendorEmail,
		VendorMobile:           vendor.VendorMobile,
		Pan:                    vendor.PAN,
		BeneficiaryName:        vendor.BeneficiaryName,
		IsActive:               &isActive,
		MsmeClassification:     msmeClass,
		Msme:                   vendor.MSME,
		MsmeRegistrationNumber: vendor.MSMERegistrationNumber,
		MaterialNature:         vendor.MaterialNature,
		GstDefaulted:           vendor.GSTDefaulted,
		Section206abVerified:   vendor.Section206ABVerified,
		IncomeTaxType:          vendor.IncomeTaxType,
		Project:                vendor.ProjectID,
		AccountName:            vendor.AccountName,
		Status:                 &vendor.Status,
		RemarksAddress:         vendor.RemarksAddress,
	}

	return r.queries.UpdateVendor(ctx, params)
}

// DeleteVendor deletes a vendor
func (r *vendorRepository) DeleteVendor(ctx context.Context, tenantID, vendorID uuid.UUID) error {
	return r.queries.DeleteVendor(ctx, sqlc.DeleteVendorParams{
		ID:       vendorID,
		TenantID: tenantID,
	})
}

// ListVendors lists vendors with filters
func (r *vendorRepository) ListVendors(ctx context.Context, tenantID uuid.UUID, filters ports.VendorListFilters) ([]*domain.Vendor, int64, error) {
	// If ProjectIDs are present (Org filtering) or other specific filters, we use simpler dynamic query building
	// This covers both specific project filter (via filters.Project) and Org filter (via filters.ProjectIDs)
	
	// 1. Build Count Query
	countQuery := `SELECT COUNT(*) FROM vendors WHERE tenant_id = $1`
	args := []interface{}{tenantID}
	argIdx := 2

	if filters.IsActive != nil {
		countQuery += fmt.Sprintf(" AND status = $%d", argIdx)
		statusVal := "ACTIVE"
		if !*filters.IsActive {
			statusVal = "INACTIVE"
		}
		args = append(args, statusVal)
		argIdx++
	}
	if filters.VendorType != nil {
		countQuery += fmt.Sprintf(" AND account_type = $%d", argIdx)
		args = append(args, *filters.VendorType)
		argIdx++
	}
	if filters.Project != nil {
		countQuery += fmt.Sprintf(" AND project_id = $%d", argIdx)
		args = append(args, *filters.Project)
		argIdx++
	}
	if len(filters.ProjectIDs) > 0 {
		countQuery += fmt.Sprintf(" AND (project_id = ANY($%d) OR project_id IS NULL)", argIdx)
		args = append(args, filters.ProjectIDs)
		argIdx++
	}
	if filters.Search != nil {
		searchTerm := "%" + *filters.Search + "%"
		countQuery += fmt.Sprintf(" AND (vendor_name ILIKE $%d OR vendor_email ILIKE $%d OR vendor_code ILIKE $%d)", argIdx, argIdx, argIdx)
		args = append(args, searchTerm)
		argIdx++
	}

	var total int64
	fmt.Printf("DEBUG: ListVendors Count Query: %s, Args: %v\n", countQuery, args)
	err := r.db.QueryRow(ctx, countQuery, args...).Scan(&total)
	if err != nil {
		fmt.Printf("DEBUG: ListVendors Count Error: %v\n", err)
		return nil, 0, fmt.Errorf("failed to count vendors: %w", err)
	}
	fmt.Printf("DEBUG: ListVendors Total Found: %d\n", total)

	// 2. Build List Query
	selectCols := `id, tenant_id, vendor_code, vendor_name, vendor_email, vendor_mobile, 
		account_type, vendor_nick_name, activity_type, email, mobile, gstin, pan, pin, 
		country_id, state_id, city_id, country_name, state_name, city_name, 
		msme_classification, msme, msme_registration_number, msme_start_date, msme_end_date, 
		material_nature, gst_defaulted, section_206ab_verified, beneficiary_name, 
		remarks_address, common_bank_details, income_tax_type, project_id, status, 
		from_account_type, account_name, short_name, parent, file_paths, 
		code_auto_generated, created_by, created_at, updated_at, 
		account_number, name_of_bank, ifsc_code, ifsc_code_id`
	
	listQuery := fmt.Sprintf("SELECT %s FROM vendors WHERE tenant_id = $1", selectCols)
	// Reuse args but handle pagination
	// We need to rebuild query string completely to ensure correct params
	
	listQueryPart := ""
	argIdx = 2
	// Re-add filters (same logic as count)
	if filters.IsActive != nil {
		listQueryPart += fmt.Sprintf(" AND status = $%d", argIdx)
		argIdx++
	}
	if filters.VendorType != nil {
		listQueryPart += fmt.Sprintf(" AND account_type = $%d", argIdx)
		argIdx++
	}
	if filters.Project != nil {
		listQueryPart += fmt.Sprintf(" AND project_id = $%d", argIdx)
		argIdx++
	}
	if len(filters.ProjectIDs) > 0 {
		listQueryPart += fmt.Sprintf(" AND (project_id = ANY($%d) OR project_id IS NULL)", argIdx)
		argIdx++
	}
	if filters.Search != nil {
		listQueryPart += fmt.Sprintf(" AND (vendor_name ILIKE $%d OR vendor_email ILIKE $%d OR vendor_code ILIKE $%d)", argIdx, argIdx, argIdx)
		argIdx++
	}

	listQuery += listQueryPart
	listQuery += fmt.Sprintf(" ORDER BY created_at DESC LIMIT $%d OFFSET $%d", argIdx, argIdx+1)
	args = append(args, filters.Limit, filters.Offset)

    // Execute Query
    rows, err := r.db.Query(ctx, listQuery, args...)
	if err != nil {
		return nil, 0, fmt.Errorf("failed to list vendors: %w", err)
	}
	defer rows.Close()

	var domainVendors []*domain.Vendor
	for rows.Next() {
		var i sqlc.Vendor
		if err := rows.Scan(
			&i.ID, &i.TenantID, &i.VendorCode, &i.VendorName, &i.VendorEmail, &i.VendorMobile,
			&i.VendorType, &i.VendorNickName, &i.ActivityType, &i.Email, &i.Mobile, &i.Gstin, &i.Pan, &i.Pin,
			&i.CountryID, &i.StateID, &i.CityID, &i.CountryName, &i.StateName, &i.CityName,
			&i.MsmeClassification, &i.Msme, &i.MsmeRegistrationNumber, &i.MsmeStartDate, &i.MsmeEndDate,
			&i.MaterialNature, &i.GstDefaulted, &i.Section206abVerified, &i.BeneficiaryName,
			&i.RemarksAddress, &i.CommonBankDetails, &i.IncomeTaxType, &i.Project, &i.Status,
			&i.FromAccountType, &i.AccountName, &i.ShortName, &i.Parent, &i.FilePaths,
			&i.CodeAutoGenerated, &i.CreatedBy, &i.CreatedAt, &i.UpdatedAt,
			&i.AccountNumber, &i.NameOfBank, &i.IfscCode, &i.IfscCodeID,
		); err != nil {
			return nil, 0, err
		}
		domainVendors = append(domainVendors, toDomainVendor(&i))
	}

	return domainVendors, total, nil
}

// IsVendorCodeExists checks if vendor code exists
func (r *vendorRepository) IsVendorCodeExists(ctx context.Context, tenantID uuid.UUID, code string, excludeID *uuid.UUID) (bool, error) {
	params := sqlc.IsVendorCodeExistsParams{
		VendorCode: code,
		TenantID:   tenantID,
	}
	// Handle optional exclude ID
	return r.queries.IsVendorCodeExists(ctx, params)
}

// IsVendorEmailExists checks if vendor email exists
func (r *vendorRepository) IsVendorEmailExists(ctx context.Context, tenantID uuid.UUID, email string, excludeID *uuid.UUID) (bool, error) {
	params := sqlc.IsVendorEmailExistsParams{
		VendorEmail: email,
		TenantID:    tenantID,
	}
	return r.queries.IsVendorEmailExists(ctx, params)
}

// WithTransaction executes a function within a transaction
func (r *vendorRepository) WithTransaction(ctx context.Context, fn func(ctx context.Context) error) error {
	tx, err := r.db.Begin(ctx)
	if err != nil {
		return fmt.Errorf("failed to begin transaction: %w", err)
	}

	defer func() {
		if p := recover(); p != nil {
			tx.Rollback(ctx)
			panic(p)
		}
	}()

	if err := fn(ctx); err != nil {
		tx.Rollback(ctx)
		return err
	}

	return tx.Commit(ctx)
}

// Helper function to convert SQLC vendor to domain vendor
func toDomainVendor(v *sqlc.Vendor) *domain.Vendor {
	vendor := &domain.Vendor{
		ID:                     v.ID,
		TenantID:               v.TenantID,
		VendorCode:             v.VendorCode,
		VendorName:             v.VendorName,
		VendorEmail:            v.VendorEmail,
		VendorMobile:           v.VendorMobile,
		AccountType:            ptrStr(v.VendorType),
		VendorNickName:         v.VendorNickName,
		ActivityType:           v.ActivityType,
		Email:                  v.Email,
		Mobile:                 v.Mobile,
		GSTIN:                  v.Gstin,
		PAN:                    v.Pan,
		PIN:                    v.Pin,
		CountryID:              v.CountryID,
		StateID:                v.StateID,
		CityID:                 v.CityID,
		CountryName:            v.CountryName,
		StateName:              v.StateName,
		CityName:               v.CityName,
		MSMEClassification:     ptrStr(v.MsmeClassification),
		MSME:                   v.Msme,
		MSMERegistrationNumber: v.MsmeRegistrationNumber,
		MaterialNature:         v.MaterialNature,
		GSTDefaulted:           v.GstDefaulted,
		Section206ABVerified:   v.Section206abVerified,
		BeneficiaryName:        v.BeneficiaryName,
		RemarksAddress:         v.RemarksAddress,
		CommonBankDetails:      v.CommonBankDetails,
		IncomeTaxType:          v.IncomeTaxType,
		ProjectID:              v.Project,
		Status:                 ptrStr(v.Status),
		FromAccountType:        v.FromAccountType,
		AccountName:            v.AccountName,
		ShortName:              v.ShortName,
		Parent:                 v.Parent,
		CodeAutoGenerated:      ptrBool(v.CodeAutoGenerated),
		CreatedBy:              v.CreatedBy,
		AccountNumber:          v.AccountNumber,
		NameOfBank:             v.NameOfBank,
		IFSCCode:               v.IfscCode,
		IFSCCodeID:             v.IfscCodeID,
	}
	
	// Convert timestamps
	if v.CreatedAt.Valid {
		vendor.CreatedAt = v.CreatedAt.Time
	}
	if v.UpdatedAt.Valid {
		vendor.UpdatedAt = v.UpdatedAt.Time
	}

	return vendor
}

// Helper functions
func strPtr(s *string) string {
	if s == nil {
		return ""
	}
	return *s
}

func ptrStr(s *string) string {
	if s == nil {
		return ""
	}
	return *s
}

func ptrBool(b *bool) bool {
	if b == nil {
		return false
	}
	return *b
}

// Vendor account methods (stub implementations for now - these need SQLC queries too)
// CreateVendorAccount creates a vendor account
func (r *vendorRepository) CreateVendorAccount(ctx context.Context, account *domain.VendorAccount) error {
	params := sqlc.CreateVendorAccountParams{
		ID:            account.ID,
		VendorID:      account.VendorID,
		AccountName:   account.AccountName,
		AccountNumber: account.AccountNumber,
		AccountType:   account.AccountType,
		NameOfBank:    account.NameOfBank,
		BranchName:    account.BranchName,
		IfscCode:      account.IFSCCode,
		SwiftCode:     account.SwiftCode,
		IsPrimary:     &account.IsPrimary,
		IsActive:      &account.IsActive,
		Remarks:       account.Remarks,
		CreatedBy:     account.CreatedBy,
	}
    // Wait, check CreatedBy type in sqlc generated struct.
    // In generated struct: CreatedBy string.
    // In domain struct: CreatedBy uuid.UUID.
    
    // I need to confirm `account.CreatedBy` type. In `domain/vendor_new.go`:
    // `CreatedBy             uuid.UUID`
    
    return r.queries.CreateVendorAccount(ctx, params)
}

func (r *vendorRepository) GetVendorAccountByID(ctx context.Context, accountID uuid.UUID) (*domain.VendorAccount, error) {
	return nil, fmt.Errorf("not implemented yet")
}

func (r *vendorRepository) GetVendorAccountsByVendorID(ctx context.Context, vendorID uuid.UUID) ([]*domain.VendorAccount, error) {
	return nil, fmt.Errorf("not implemented yet")
}

func (r *vendorRepository) GetPrimaryVendorAccount(ctx context.Context, vendorID uuid.UUID) (*domain.VendorAccount, error) {
	return nil, fmt.Errorf("not implemented yet")
}

func (r *vendorRepository) UpdateVendorAccount(ctx context.Context, account *domain.VendorAccount) error {
	return fmt.Errorf("not implemented yet")
}

func (r *vendorRepository) DeleteVendorAccount(ctx context.Context, accountID uuid.UUID) error {
	return fmt.Errorf("not implemented yet")
}

// UnsetPrimaryVendorAccounts unsets primary status for all accounts of a vendor
func (r *vendorRepository) UnsetPrimaryVendorAccounts(ctx context.Context, vendorID uuid.UUID, excludeAccountID *uuid.UUID) error {
	var excludeID pgtype.UUID
	
	if excludeAccountID != nil {
		excludeID = pgtype.UUID{Bytes: *excludeAccountID, Valid: true}
	} else {
		excludeID = pgtype.UUID{Valid: false}
	}

	params := sqlc.UnsetPrimaryVendorAccountsParams{
		VendorID: vendorID,
		Column2:  excludeID,
	}

	return r.queries.UnsetPrimaryVendorAccounts(ctx, params)
}
