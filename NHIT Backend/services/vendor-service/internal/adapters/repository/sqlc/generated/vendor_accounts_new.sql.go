// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: vendor_accounts_new.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createVendorAccount = `-- name: CreateVendorAccount :exec
INSERT INTO vendor_accounts (
    id, vendor_id, account_name, account_number, account_type,
    name_of_bank, branch_name, ifsc_code, swift_code,
    is_primary, is_active, remarks, created_by
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13
)
`

type CreateVendorAccountParams struct {
	ID            uuid.UUID `db:"id" json:"id"`
	VendorID      uuid.UUID `db:"vendor_id" json:"vendor_id"`
	AccountName   string    `db:"account_name" json:"account_name"`
	AccountNumber string    `db:"account_number" json:"account_number"`
	AccountType   *string   `db:"account_type" json:"account_type"`
	NameOfBank    string    `db:"name_of_bank" json:"name_of_bank"`
	BranchName    *string   `db:"branch_name" json:"branch_name"`
	IfscCode      string    `db:"ifsc_code" json:"ifsc_code"`
	SwiftCode     *string   `db:"swift_code" json:"swift_code"`
	IsPrimary     *bool     `db:"is_primary" json:"is_primary"`
	IsActive      *bool     `db:"is_active" json:"is_active"`
	Remarks       *string   `db:"remarks" json:"remarks"`
	CreatedBy     uuid.UUID `db:"created_by" json:"created_by"`
}

func (q *Queries) CreateVendorAccount(ctx context.Context, arg CreateVendorAccountParams) error {
	_, err := q.db.Exec(ctx, createVendorAccount,
		arg.ID,
		arg.VendorID,
		arg.AccountName,
		arg.AccountNumber,
		arg.AccountType,
		arg.NameOfBank,
		arg.BranchName,
		arg.IfscCode,
		arg.SwiftCode,
		arg.IsPrimary,
		arg.IsActive,
		arg.Remarks,
		arg.CreatedBy,
	)
	return err
}

const deleteVendorAccount = `-- name: DeleteVendorAccount :exec
DELETE FROM vendor_accounts 
WHERE id = $1
`

func (q *Queries) DeleteVendorAccount(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteVendorAccount, id)
	return err
}

const getPrimaryVendorAccount = `-- name: GetPrimaryVendorAccount :one
SELECT id, vendor_id, account_name, account_number, account_type, name_of_bank, branch_name, ifsc_code, swift_code, is_primary, is_active, remarks, created_by, created_at, updated_at FROM vendor_accounts 
WHERE vendor_id = $1 AND is_primary = true AND is_active = true
LIMIT 1
`

func (q *Queries) GetPrimaryVendorAccount(ctx context.Context, vendorID uuid.UUID) (*VendorAccount, error) {
	row := q.db.QueryRow(ctx, getPrimaryVendorAccount, vendorID)
	var i VendorAccount
	err := row.Scan(
		&i.ID,
		&i.VendorID,
		&i.AccountName,
		&i.AccountNumber,
		&i.AccountType,
		&i.NameOfBank,
		&i.BranchName,
		&i.IfscCode,
		&i.SwiftCode,
		&i.IsPrimary,
		&i.IsActive,
		&i.Remarks,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getVendorAccountByID = `-- name: GetVendorAccountByID :one
SELECT id, vendor_id, account_name, account_number, account_type, name_of_bank, branch_name, ifsc_code, swift_code, is_primary, is_active, remarks, created_by, created_at, updated_at FROM vendor_accounts 
WHERE id = $1
`

func (q *Queries) GetVendorAccountByID(ctx context.Context, id uuid.UUID) (*VendorAccount, error) {
	row := q.db.QueryRow(ctx, getVendorAccountByID, id)
	var i VendorAccount
	err := row.Scan(
		&i.ID,
		&i.VendorID,
		&i.AccountName,
		&i.AccountNumber,
		&i.AccountType,
		&i.NameOfBank,
		&i.BranchName,
		&i.IfscCode,
		&i.SwiftCode,
		&i.IsPrimary,
		&i.IsActive,
		&i.Remarks,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getVendorAccountsByVendorID = `-- name: GetVendorAccountsByVendorID :many
SELECT id, vendor_id, account_name, account_number, account_type, name_of_bank, branch_name, ifsc_code, swift_code, is_primary, is_active, remarks, created_by, created_at, updated_at FROM vendor_accounts 
WHERE vendor_id = $1
ORDER BY is_primary DESC, created_at ASC
`

func (q *Queries) GetVendorAccountsByVendorID(ctx context.Context, vendorID uuid.UUID) ([]*VendorAccount, error) {
	rows, err := q.db.Query(ctx, getVendorAccountsByVendorID, vendorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*VendorAccount{}
	for rows.Next() {
		var i VendorAccount
		if err := rows.Scan(
			&i.ID,
			&i.VendorID,
			&i.AccountName,
			&i.AccountNumber,
			&i.AccountType,
			&i.NameOfBank,
			&i.BranchName,
			&i.IfscCode,
			&i.SwiftCode,
			&i.IsPrimary,
			&i.IsActive,
			&i.Remarks,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setAccountAsPrimary = `-- name: SetAccountAsPrimary :exec
UPDATE vendor_accounts SET
    is_primary = true,
    updated_at = NOW()
WHERE id = $1
`

func (q *Queries) SetAccountAsPrimary(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, setAccountAsPrimary, id)
	return err
}

const toggleVendorAccountStatus = `-- name: ToggleVendorAccountStatus :exec
UPDATE vendor_accounts SET
    is_active = NOT is_active,
    updated_at = NOW()
WHERE id = $1
`

func (q *Queries) ToggleVendorAccountStatus(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, toggleVendorAccountStatus, id)
	return err
}

const unsetPrimaryVendorAccounts = `-- name: UnsetPrimaryVendorAccounts :exec
UPDATE vendor_accounts SET
    is_primary = false,
    updated_at = NOW()
WHERE vendor_id = $1 
    AND ($2::uuid IS NULL OR id != $2)
    AND is_primary = true
`

type UnsetPrimaryVendorAccountsParams struct {
	VendorID uuid.UUID   `db:"vendor_id" json:"vendor_id"`
	Column2  pgtype.UUID `db:"column_2" json:"column_2"`
}

func (q *Queries) UnsetPrimaryVendorAccounts(ctx context.Context, arg UnsetPrimaryVendorAccountsParams) error {
	_, err := q.db.Exec(ctx, unsetPrimaryVendorAccounts, arg.VendorID, arg.Column2)
	return err
}

const updateVendorAccount = `-- name: UpdateVendorAccount :exec
UPDATE vendor_accounts SET
    account_name = COALESCE($2, account_name),
    account_number = COALESCE($3, account_number),
    account_type = COALESCE($4, account_type),
    name_of_bank = COALESCE($5, name_of_bank),
    branch_name = COALESCE($6, branch_name),
    ifsc_code = COALESCE($7, ifsc_code),
    swift_code = COALESCE($8, swift_code),
    is_primary = COALESCE($9, is_primary),
    is_active = COALESCE($10, is_active),
    remarks = COALESCE($11, remarks),
    updated_at = NOW()
WHERE id = $1
`

type UpdateVendorAccountParams struct {
	ID            uuid.UUID `db:"id" json:"id"`
	AccountName   string    `db:"account_name" json:"account_name"`
	AccountNumber string    `db:"account_number" json:"account_number"`
	AccountType   *string   `db:"account_type" json:"account_type"`
	NameOfBank    string    `db:"name_of_bank" json:"name_of_bank"`
	BranchName    *string   `db:"branch_name" json:"branch_name"`
	IfscCode      string    `db:"ifsc_code" json:"ifsc_code"`
	SwiftCode     *string   `db:"swift_code" json:"swift_code"`
	IsPrimary     *bool     `db:"is_primary" json:"is_primary"`
	IsActive      *bool     `db:"is_active" json:"is_active"`
	Remarks       *string   `db:"remarks" json:"remarks"`
}

func (q *Queries) UpdateVendorAccount(ctx context.Context, arg UpdateVendorAccountParams) error {
	_, err := q.db.Exec(ctx, updateVendorAccount,
		arg.ID,
		arg.AccountName,
		arg.AccountNumber,
		arg.AccountType,
		arg.NameOfBank,
		arg.BranchName,
		arg.IfscCode,
		arg.SwiftCode,
		arg.IsPrimary,
		arg.IsActive,
		arg.Remarks,
	)
	return err
}
