// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: vendors_new.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countVendors = `-- name: CountVendors :one
SELECT COUNT(*) FROM vendors 
WHERE tenant_id = $1
    AND ($2::boolean IS NULL OR is_active = $2)
    AND ($3::text IS NULL OR vendor_type = $3)
    AND ($4::text IS NULL OR project = $4)
    AND ($5::text IS NULL OR (
        vendor_name ILIKE '%' || $5 || '%' OR
        vendor_email ILIKE '%' || $5 || '%' OR
        vendor_code ILIKE '%' || $5 || '%'
    ))
`

type CountVendorsParams struct {
	TenantID uuid.UUID `db:"tenant_id" json:"tenant_id"`
	Column2  bool      `db:"column_2" json:"column_2"`
	Column3  string    `db:"column_3" json:"column_3"`
	Column4  string    `db:"column_4" json:"column_4"`
	Column5  string    `db:"column_5" json:"column_5"`
}

func (q *Queries) CountVendors(ctx context.Context, arg CountVendorsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countVendors,
		arg.TenantID,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createVendor = `-- name: CreateVendor :exec
INSERT INTO vendors (
    id, tenant_id, vendor_code, vendor_name, vendor_email, vendor_mobile,
    account_type, vendor_nick_name, activity_type, email, mobile, gstin, pan, pin,
    country_id, state_id, city_id, country_name, state_name, city_name,
    msme_classification, msme, msme_registration_number, msme_start_date, msme_end_date,
    material_nature, gst_defaulted, section_206ab_verified, beneficiary_name,
    remarks_address, common_bank_details, income_tax_type, project_id, status,
    from_account_type, account_name, short_name, parent, file_paths,
    code_auto_generated, created_by, account_number, name_of_bank,
    ifsc_code, ifsc_code_id
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20,
    $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31, $32, $33, $34, $35, $36, $37, $38, $39,
    $40, $41, $42, $43, $44, $45
)
`

type CreateVendorParams struct {
	ID                     uuid.UUID   `db:"id" json:"id"`
	TenantID               uuid.UUID   `db:"tenant_id" json:"tenant_id"`
	VendorCode             string      `db:"vendor_code" json:"vendor_code"`
	VendorName             string      `db:"vendor_name" json:"vendor_name"`
	VendorEmail            string      `db:"vendor_email" json:"vendor_email"`
	VendorMobile           *string     `db:"vendor_mobile" json:"vendor_mobile"`
	VendorType             *string     `db:"vendor_type" json:"vendor_type"`
	VendorNickName         *string     `db:"vendor_nick_name" json:"vendor_nick_name"`
	ActivityType           *string     `db:"activity_type" json:"activity_type"`
	Email                  *string     `db:"email" json:"email"`
	Mobile                 *string     `db:"mobile" json:"mobile"`
	Gstin                  *string     `db:"gstin" json:"gstin"`
	Pan                    string      `db:"pan" json:"pan"`
	Pin                    *string     `db:"pin" json:"pin"`
	CountryID              *string     `db:"country_id" json:"country_id"`
	StateID                *string     `db:"state_id" json:"state_id"`
	CityID                 *string     `db:"city_id" json:"city_id"`
	CountryName            *string     `db:"country_name" json:"country_name"`
	StateName              *string     `db:"state_name" json:"state_name"`
	CityName               *string     `db:"city_name" json:"city_name"`
	MsmeClassification     *string     `db:"msme_classification" json:"msme_classification"`
	Msme                   *string     `db:"msme" json:"msme"`
	MsmeRegistrationNumber *string     `db:"msme_registration_number" json:"msme_registration_number"`
	MsmeStartDate          pgtype.Date `db:"msme_start_date" json:"msme_start_date"`
	MsmeEndDate            pgtype.Date `db:"msme_end_date" json:"msme_end_date"`
	MaterialNature         *string     `db:"material_nature" json:"material_nature"`
	GstDefaulted           *string     `db:"gst_defaulted" json:"gst_defaulted"`
	Section206abVerified   *string     `db:"section_206ab_verified" json:"section_206ab_verified"`
	BeneficiaryName        string      `db:"beneficiary_name" json:"beneficiary_name"`
	RemarksAddress         *string     `db:"remarks_address" json:"remarks_address"`
	CommonBankDetails      *string     `db:"common_bank_details" json:"common_bank_details"`
	IncomeTaxType          *string     `db:"income_tax_type" json:"income_tax_type"`
	Project                *string     `db:"project" json:"project"`
	Status                 *string     `db:"status" json:"status"`
	FromAccountType        *string     `db:"from_account_type" json:"from_account_type"`
	AccountName            *string     `db:"account_name" json:"account_name"`
	ShortName              *string     `db:"short_name" json:"short_name"`
	Parent                 *string     `db:"parent" json:"parent"`
	FilePaths              []byte      `db:"file_paths" json:"file_paths"`
	CodeAutoGenerated      *bool       `db:"code_auto_generated" json:"code_auto_generated"`
	IsActive               *bool       `db:"is_active" json:"is_active"`
	CreatedBy              uuid.UUID   `db:"created_by" json:"created_by"`
	AccountNumber          *string     `db:"account_number" json:"account_number"`
	NameOfBank             *string     `db:"name_of_bank" json:"name_of_bank"`
	IfscCode               *string     `db:"ifsc_code" json:"ifsc_code"`
	IfscCodeID             *string     `db:"ifsc_code_id" json:"ifsc_code_id"`
}

func (q *Queries) CreateVendor(ctx context.Context, arg CreateVendorParams) error {
	_, err := q.db.Exec(ctx, createVendor,
		arg.ID,
		arg.TenantID,
		arg.VendorCode,
		arg.VendorName,
		arg.VendorEmail,
		arg.VendorMobile,
		arg.VendorType,
		arg.VendorNickName,
		arg.ActivityType,
		arg.Email,
		arg.Mobile,
		arg.Gstin,
		arg.Pan,
		arg.Pin,
		arg.CountryID,
		arg.StateID,
		arg.CityID,
		arg.CountryName,
		arg.StateName,
		arg.CityName,
		arg.MsmeClassification,
		arg.Msme,
		arg.MsmeRegistrationNumber,
		arg.MsmeStartDate,
		arg.MsmeEndDate,
		arg.MaterialNature,
		arg.GstDefaulted,
		arg.Section206abVerified,
		arg.BeneficiaryName,
		arg.RemarksAddress,
		arg.CommonBankDetails,
		arg.IncomeTaxType,
		arg.Project,
		arg.Status,
		arg.FromAccountType,
		arg.AccountName,
		arg.ShortName,
		arg.Parent,
		arg.FilePaths,
		arg.CodeAutoGenerated,
		arg.CreatedBy,
		arg.AccountNumber,
		arg.NameOfBank,
		arg.IfscCode,
		arg.IfscCodeID,
	)
	return err
}

const deleteVendor = `-- name: DeleteVendor :exec
DELETE FROM vendors 
WHERE id = $1 AND tenant_id = $2
`

type DeleteVendorParams struct {
	ID       uuid.UUID `db:"id" json:"id"`
	TenantID uuid.UUID `db:"tenant_id" json:"tenant_id"`
}

func (q *Queries) DeleteVendor(ctx context.Context, arg DeleteVendorParams) error {
	_, err := q.db.Exec(ctx, deleteVendor, arg.ID, arg.TenantID)
	return err
}

const getVendorByCode = `-- name: GetVendorByCode :one
SELECT id, tenant_id, vendor_code, vendor_name, vendor_email, vendor_mobile, account_type, vendor_nick_name, activity_type, email, mobile, gstin, pan, pin, country_id, state_id, city_id, country_name, state_name, city_name, msme_classification, msme, msme_registration_number, msme_start_date, msme_end_date, material_nature, gst_defaulted, section_206ab_verified, beneficiary_name, remarks_address, common_bank_details, income_tax_type, project_id, status, from_account_type, account_name, short_name, parent, file_paths, code_auto_generated, (status = 'ACTIVE') as is_active, created_by, created_at, updated_at, account_number, name_of_bank, ifsc_code, ifsc_code_id FROM vendors 
WHERE vendor_code = $1 AND tenant_id = $2
`

type GetVendorByCodeParams struct {
	VendorCode string    `db:"vendor_code" json:"vendor_code"`
	TenantID   uuid.UUID `db:"tenant_id" json:"tenant_id"`
}

func (q *Queries) GetVendorByCode(ctx context.Context, arg GetVendorByCodeParams) (*Vendor, error) {
	row := q.db.QueryRow(ctx, getVendorByCode, arg.VendorCode, arg.TenantID)
	var i Vendor
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.VendorCode,
		&i.VendorName,
		&i.VendorEmail,
		&i.VendorMobile,
		&i.VendorType,
		&i.VendorNickName,
		&i.ActivityType,
		&i.Email,
		&i.Mobile,
		&i.Gstin,
		&i.Pan,
		&i.Pin,
		&i.CountryID,
		&i.StateID,
		&i.CityID,
		&i.CountryName,
		&i.StateName,
		&i.CityName,
		&i.MsmeClassification,
		&i.Msme,
		&i.MsmeRegistrationNumber,
		&i.MsmeStartDate,
		&i.MsmeEndDate,
		&i.MaterialNature,
		&i.GstDefaulted,
		&i.Section206abVerified,
		&i.BeneficiaryName,
		&i.RemarksAddress,
		&i.CommonBankDetails,
		&i.IncomeTaxType,
		&i.Project,
		&i.Status,
		&i.FromAccountType,
		&i.AccountName,
		&i.ShortName,
		&i.Parent,
		&i.FilePaths,
		&i.CodeAutoGenerated,
		&i.IsActive,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AccountNumber,
		&i.NameOfBank,
		&i.IfscCode,
		&i.IfscCodeID,
	)
	return &i, err
}

const getVendorByEmail = `-- name: GetVendorByEmail :one
SELECT id, tenant_id, vendor_code, vendor_name, vendor_email, vendor_mobile, account_type, vendor_nick_name, activity_type, email, mobile, gstin, pan, pin, country_id, state_id, city_id, country_name, state_name, city_name, msme_classification, msme, msme_registration_number, msme_start_date, msme_end_date, material_nature, gst_defaulted, section_206ab_verified, beneficiary_name, remarks_address, common_bank_details, income_tax_type, project_id, status, from_account_type, account_name, short_name, parent, file_paths, code_auto_generated, (status = 'ACTIVE') as is_active, created_by, created_at, updated_at, account_number, name_of_bank, ifsc_code, ifsc_code_id FROM vendors 
WHERE vendor_email = $1 AND tenant_id = $2
`

type GetVendorByEmailParams struct {
	VendorEmail string    `db:"vendor_email" json:"vendor_email"`
	TenantID    uuid.UUID `db:"tenant_id" json:"tenant_id"`
}

func (q *Queries) GetVendorByEmail(ctx context.Context, arg GetVendorByEmailParams) (*Vendor, error) {
	row := q.db.QueryRow(ctx, getVendorByEmail, arg.VendorEmail, arg.TenantID)
	var i Vendor
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.VendorCode,
		&i.VendorName,
		&i.VendorEmail,
		&i.VendorMobile,
		&i.VendorType,
		&i.VendorNickName,
		&i.ActivityType,
		&i.Email,
		&i.Mobile,
		&i.Gstin,
		&i.Pan,
		&i.Pin,
		&i.CountryID,
		&i.StateID,
		&i.CityID,
		&i.CountryName,
		&i.StateName,
		&i.CityName,
		&i.MsmeClassification,
		&i.Msme,
		&i.MsmeRegistrationNumber,
		&i.MsmeStartDate,
		&i.MsmeEndDate,
		&i.MaterialNature,
		&i.GstDefaulted,
		&i.Section206abVerified,
		&i.BeneficiaryName,
		&i.RemarksAddress,
		&i.CommonBankDetails,
		&i.IncomeTaxType,
		&i.Project,
		&i.Status,
		&i.FromAccountType,
		&i.AccountName,
		&i.ShortName,
		&i.Parent,
		&i.FilePaths,
		&i.CodeAutoGenerated,
		&i.IsActive,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AccountNumber,
		&i.NameOfBank,
		&i.IfscCode,
		&i.IfscCodeID,
	)
	return &i, err
}

const getVendorByID = `-- name: GetVendorByID :one
SELECT id, tenant_id, vendor_code, vendor_name, vendor_email, vendor_mobile, account_type, vendor_nick_name, activity_type, email, mobile, gstin, pan, pin, country_id, state_id, city_id, country_name, state_name, city_name, msme_classification, msme, msme_registration_number, msme_start_date, msme_end_date, material_nature, gst_defaulted, section_206ab_verified, beneficiary_name, remarks_address, common_bank_details, income_tax_type, project_id, status, from_account_type, account_name, short_name, parent, file_paths, code_auto_generated, (status = 'ACTIVE') as is_active, created_by, created_at, updated_at, account_number, name_of_bank, ifsc_code, ifsc_code_id FROM vendors 
WHERE id = $1 AND tenant_id = $2
`

type GetVendorByIDParams struct {
	ID       uuid.UUID `db:"id" json:"id"`
	TenantID uuid.UUID `db:"tenant_id" json:"tenant_id"`
}

func (q *Queries) GetVendorByID(ctx context.Context, arg GetVendorByIDParams) (*Vendor, error) {
	row := q.db.QueryRow(ctx, getVendorByID, arg.ID, arg.TenantID)
	var i Vendor
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.VendorCode,
		&i.VendorName,
		&i.VendorEmail,
		&i.VendorMobile,
		&i.VendorType,
		&i.VendorNickName,
		&i.ActivityType,
		&i.Email,
		&i.Mobile,
		&i.Gstin,
		&i.Pan,
		&i.Pin,
		&i.CountryID,
		&i.StateID,
		&i.CityID,
		&i.CountryName,
		&i.StateName,
		&i.CityName,
		&i.MsmeClassification,
		&i.Msme,
		&i.MsmeRegistrationNumber,
		&i.MsmeStartDate,
		&i.MsmeEndDate,
		&i.MaterialNature,
		&i.GstDefaulted,
		&i.Section206abVerified,
		&i.BeneficiaryName,
		&i.RemarksAddress,
		&i.CommonBankDetails,
		&i.IncomeTaxType,
		&i.Project,
		&i.Status,
		&i.FromAccountType,
		&i.AccountName,
		&i.ShortName,
		&i.Parent,
		&i.FilePaths,
		&i.CodeAutoGenerated,
		&i.IsActive,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AccountNumber,
		&i.NameOfBank,
		&i.IfscCode,
		&i.IfscCodeID,
	)
	return &i, err
}

const isVendorCodeExists = `-- name: IsVendorCodeExists :one
SELECT EXISTS(
    SELECT 1 FROM vendors 
    WHERE vendor_code = $1 AND tenant_id = $2
    AND ($3::uuid IS NULL OR id != $3)
)
`

type IsVendorCodeExistsParams struct {
	VendorCode string      `db:"vendor_code" json:"vendor_code"`
	TenantID   uuid.UUID   `db:"tenant_id" json:"tenant_id"`
	Column3    pgtype.UUID `db:"column_3" json:"column_3"`
}

func (q *Queries) IsVendorCodeExists(ctx context.Context, arg IsVendorCodeExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, isVendorCodeExists, arg.VendorCode, arg.TenantID, arg.Column3)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const isVendorEmailExists = `-- name: IsVendorEmailExists :one
SELECT EXISTS(
    SELECT 1 FROM vendors 
    WHERE vendor_email = $1 AND tenant_id = $2
    AND ($3::uuid IS NULL OR id != $3)
)
`

type IsVendorEmailExistsParams struct {
	VendorEmail string      `db:"vendor_email" json:"vendor_email"`
	TenantID    uuid.UUID   `db:"tenant_id" json:"tenant_id"`
	Column3     pgtype.UUID `db:"column_3" json:"column_3"`
}

func (q *Queries) IsVendorEmailExists(ctx context.Context, arg IsVendorEmailExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, isVendorEmailExists, arg.VendorEmail, arg.TenantID, arg.Column3)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const listVendors = `-- name: ListVendors :many
SELECT id, tenant_id, vendor_code, vendor_name, vendor_email, vendor_mobile, account_type, vendor_nick_name, activity_type, email, mobile, gstin, pan, pin, country_id, state_id, city_id, country_name, state_name, city_name, msme_classification, msme, msme_registration_number, msme_start_date, msme_end_date, material_nature, gst_defaulted, section_206ab_verified, beneficiary_name, remarks_address, common_bank_details, income_tax_type, project_id, status, from_account_type, account_name, short_name, parent, file_paths, code_auto_generated, (status = 'ACTIVE') as is_active, created_by, created_at, updated_at, account_number, name_of_bank, ifsc_code, ifsc_code_id FROM vendors 
WHERE tenant_id = $1
    AND ($2::boolean IS NULL OR ($2 = true AND status = 'ACTIVE') OR ($2 = false AND status != 'ACTIVE'))
    AND ($3::text IS NULL OR account_type::text = $3)
    AND ($4::text IS NULL OR project_id = $4)
    AND ($5::text IS NULL OR (
        vendor_name ILIKE '%' || $5 || '%' OR
        vendor_email ILIKE '%' || $5 || '%' OR
        vendor_code ILIKE '%' || $5 || '%'
    ))
ORDER BY created_at DESC
LIMIT $6 OFFSET $7
`

type ListVendorsParams struct {
	TenantID uuid.UUID `db:"tenant_id" json:"tenant_id"`
	Column2  bool      `db:"column_2" json:"column_2"`
	Column3  string    `db:"column_3" json:"column_3"`
	Column4  string    `db:"column_4" json:"column_4"`
	Column5  string    `db:"column_5" json:"column_5"`
	Limit    int32     `db:"limit" json:"limit"`
	Offset   int32     `db:"offset" json:"offset"`
}

func (q *Queries) ListVendors(ctx context.Context, arg ListVendorsParams) ([]*Vendor, error) {
	rows, err := q.db.Query(ctx, listVendors,
		arg.TenantID,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Vendor{}
	for rows.Next() {
		var i Vendor
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.VendorCode,
			&i.VendorName,
			&i.VendorEmail,
			&i.VendorMobile,
			&i.VendorType,
			&i.VendorNickName,
			&i.ActivityType,
			&i.Email,
			&i.Mobile,
			&i.Gstin,
			&i.Pan,
			&i.Pin,
			&i.CountryID,
			&i.StateID,
			&i.CityID,
			&i.CountryName,
			&i.StateName,
			&i.CityName,
			&i.MsmeClassification,
			&i.Msme,
			&i.MsmeRegistrationNumber,
			&i.MsmeStartDate,
			&i.MsmeEndDate,
			&i.MaterialNature,
			&i.GstDefaulted,
			&i.Section206abVerified,
			&i.BeneficiaryName,
			&i.RemarksAddress,
			&i.CommonBankDetails,
			&i.IncomeTaxType,
			&i.Project,
			&i.Status,
			&i.FromAccountType,
			&i.AccountName,
			&i.ShortName,
			&i.Parent,
			&i.FilePaths,
			&i.CodeAutoGenerated,
			&i.IsActive,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AccountNumber,
			&i.NameOfBank,
			&i.IfscCode,
			&i.IfscCodeID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateVendor = `-- name: UpdateVendor :exec
UPDATE vendors SET
    vendor_name = COALESCE($3, vendor_name),
    vendor_email = COALESCE($4, vendor_email),
    vendor_mobile = COALESCE($5, vendor_mobile),
    pan = COALESCE($6, pan),
    beneficiary_name = COALESCE($7, beneficiary_name),
    is_active = COALESCE($8, is_active),
    msme_classification = COALESCE($9, msme_classification),
    msme = COALESCE($10, msme),
    msme_registration_number = COALESCE($11, msme_registration_number),
    material_nature = COALESCE($12, material_nature),
    gst_defaulted = COALESCE($13, gst_defaulted),
    section_206ab_verified = COALESCE($14, section_206ab_verified),
    income_tax_type = COALESCE($15, income_tax_type),
    project_id = COALESCE($16, project_id),
    account_name = COALESCE($17, account_name),
    status = COALESCE($18, status),
    remarks_address = COALESCE($19, remarks_address),
    updated_at = NOW()
WHERE id = $1 AND tenant_id = $2
`

type UpdateVendorParams struct {
	ID                     uuid.UUID `db:"id" json:"id"`
	TenantID               uuid.UUID `db:"tenant_id" json:"tenant_id"`
	VendorName             string    `db:"vendor_name" json:"vendor_name"`
	VendorEmail            string    `db:"vendor_email" json:"vendor_email"`
	VendorMobile           *string   `db:"vendor_mobile" json:"vendor_mobile"`
	Pan                    string    `db:"pan" json:"pan"`
	BeneficiaryName        string    `db:"beneficiary_name" json:"beneficiary_name"`
	IsActive               *bool     `db:"is_active" json:"is_active"`
	MsmeClassification     *string   `db:"msme_classification" json:"msme_classification"`
	Msme                   *string   `db:"msme" json:"msme"`
	MsmeRegistrationNumber *string   `db:"msme_registration_number" json:"msme_registration_number"`
	MaterialNature         *string   `db:"material_nature" json:"material_nature"`
	GstDefaulted           *string   `db:"gst_defaulted" json:"gst_defaulted"`
	Section206abVerified   *string   `db:"section_206ab_verified" json:"section_206ab_verified"`
	IncomeTaxType          *string   `db:"income_tax_type" json:"income_tax_type"`
	Project                *string   `db:"project" json:"project"`
	AccountName            *string   `db:"account_name" json:"account_name"`
	Status                 *string   `db:"status" json:"status"`
	RemarksAddress         *string   `db:"remarks_address" json:"remarks_address"`
}

func (q *Queries) UpdateVendor(ctx context.Context, arg UpdateVendorParams) error {
	_, err := q.db.Exec(ctx, updateVendor,
		arg.ID,
		arg.TenantID,
		arg.VendorName,
		arg.VendorEmail,
		arg.VendorMobile,
		arg.Pan,
		arg.BeneficiaryName,
		arg.IsActive,
		arg.MsmeClassification,
		arg.Msme,
		arg.MsmeRegistrationNumber,
		arg.MaterialNature,
		arg.GstDefaulted,
		arg.Section206abVerified,
		arg.IncomeTaxType,
		arg.Project,
		arg.AccountName,
		arg.Status,
		arg.RemarksAddress,
	)
	return err
}

const updateVendorCode = `-- name: UpdateVendorCode :exec
UPDATE vendors SET
    vendor_code = $3,
    code_auto_generated = $4,
    updated_at = NOW()
WHERE id = $1 AND tenant_id = $2
`

type UpdateVendorCodeParams struct {
	ID                uuid.UUID `db:"id" json:"id"`
	TenantID          uuid.UUID `db:"tenant_id" json:"tenant_id"`
	VendorCode        string    `db:"vendor_code" json:"vendor_code"`
	CodeAutoGenerated *bool     `db:"code_auto_generated" json:"code_auto_generated"`
}

func (q *Queries) UpdateVendorCode(ctx context.Context, arg UpdateVendorCodeParams) error {
	_, err := q.db.Exec(ctx, updateVendorCode,
		arg.ID,
		arg.TenantID,
	)
	return err
}