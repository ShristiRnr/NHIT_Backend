// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: organizations.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const checkOrganizationCodeExists = `-- name: CheckOrganizationCodeExists :one
SELECT EXISTS(
    SELECT 1 FROM organizations
    WHERE code = $1 AND tenant_id = $2
) AS exists
`

type CheckOrganizationCodeExistsParams struct {
	Code     string    `db:"code" json:"code"`
	TenantID uuid.UUID `db:"tenant_id" json:"tenant_id"`
}

func (q *Queries) CheckOrganizationCodeExists(ctx context.Context, arg CheckOrganizationCodeExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkOrganizationCodeExists, arg.Code, arg.TenantID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const countOrganizationsByTenant = `-- name: CountOrganizationsByTenant :one
SELECT COUNT(*) FROM organizations
WHERE tenant_id = $1
`

func (q *Queries) CountOrganizationsByTenant(ctx context.Context, tenantID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countOrganizationsByTenant, tenantID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createOrganization = `-- name: CreateOrganization :one
INSERT INTO organizations (
    org_id, tenant_id, name, code, database_name,
    description, logo, is_active, created_by,
    created_at, updated_at
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
RETURNING org_id, tenant_id, name, code, database_name, description, logo, is_active, created_by, created_at, updated_at
`

type CreateOrganizationParams struct {
	OrgID        uuid.UUID        `db:"org_id" json:"org_id"`
	TenantID     uuid.UUID        `db:"tenant_id" json:"tenant_id"`
	Name         string           `db:"name" json:"name"`
	Code         string           `db:"code" json:"code"`
	DatabaseName string           `db:"database_name" json:"database_name"`
	Description  *string          `db:"description" json:"description"`
	Logo         *string          `db:"logo" json:"logo"`
	IsActive     bool             `db:"is_active" json:"is_active"`
	CreatedBy    uuid.UUID        `db:"created_by" json:"created_by"`
	CreatedAt    pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt    pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

func (q *Queries) CreateOrganization(ctx context.Context, arg CreateOrganizationParams) (*Organization, error) {
	row := q.db.QueryRow(ctx, createOrganization,
		arg.OrgID,
		arg.TenantID,
		arg.Name,
		arg.Code,
		arg.DatabaseName,
		arg.Description,
		arg.Logo,
		arg.IsActive,
		arg.CreatedBy,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Organization
	err := row.Scan(
		&i.OrgID,
		&i.TenantID,
		&i.Name,
		&i.Code,
		&i.DatabaseName,
		&i.Description,
		&i.Logo,
		&i.IsActive,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const deleteOrganization = `-- name: DeleteOrganization :exec
DELETE FROM organizations
WHERE org_id = $1 AND tenant_id = $2
`

type DeleteOrganizationParams struct {
	OrgID    uuid.UUID `db:"org_id" json:"org_id"`
	TenantID uuid.UUID `db:"tenant_id" json:"tenant_id"`
}

func (q *Queries) DeleteOrganization(ctx context.Context, arg DeleteOrganizationParams) error {
	_, err := q.db.Exec(ctx, deleteOrganization, arg.OrgID, arg.TenantID)
	return err
}

const getOrganizationByCode = `-- name: GetOrganizationByCode :one
SELECT org_id, tenant_id, name, code, database_name, description, logo, is_active, created_by, created_at, updated_at FROM organizations
WHERE code = $1 AND tenant_id = $2
`

type GetOrganizationByCodeParams struct {
	Code     string    `db:"code" json:"code"`
	TenantID uuid.UUID `db:"tenant_id" json:"tenant_id"`
}

func (q *Queries) GetOrganizationByCode(ctx context.Context, arg GetOrganizationByCodeParams) (*Organization, error) {
	row := q.db.QueryRow(ctx, getOrganizationByCode, arg.Code, arg.TenantID)
	var i Organization
	err := row.Scan(
		&i.OrgID,
		&i.TenantID,
		&i.Name,
		&i.Code,
		&i.DatabaseName,
		&i.Description,
		&i.Logo,
		&i.IsActive,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getOrganizationByID = `-- name: GetOrganizationByID :one
SELECT org_id, tenant_id, name, code, database_name, description, logo, is_active, created_by, created_at, updated_at FROM organizations
WHERE org_id = $1 AND tenant_id = $2
`

type GetOrganizationByIDParams struct {
	OrgID    uuid.UUID `db:"org_id" json:"org_id"`
	TenantID uuid.UUID `db:"tenant_id" json:"tenant_id"`
}

func (q *Queries) GetOrganizationByID(ctx context.Context, arg GetOrganizationByIDParams) (*Organization, error) {
	row := q.db.QueryRow(ctx, getOrganizationByID, arg.OrgID, arg.TenantID)
	var i Organization
	err := row.Scan(
		&i.OrgID,
		&i.TenantID,
		&i.Name,
		&i.Code,
		&i.DatabaseName,
		&i.Description,
		&i.Logo,
		&i.IsActive,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const listOrganizationsByTenant = `-- name: ListOrganizationsByTenant :many
SELECT org_id, tenant_id, name, code, database_name, description, logo, is_active, created_by, created_at, updated_at FROM organizations
WHERE tenant_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListOrganizationsByTenantParams struct {
	TenantID uuid.UUID `db:"tenant_id" json:"tenant_id"`
	Limit    int32     `db:"limit" json:"limit"`
	Offset   int32     `db:"offset" json:"offset"`
}

func (q *Queries) ListOrganizationsByTenant(ctx context.Context, arg ListOrganizationsByTenantParams) ([]*Organization, error) {
	rows, err := q.db.Query(ctx, listOrganizationsByTenant, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Organization{}
	for rows.Next() {
		var i Organization
		if err := rows.Scan(
			&i.OrgID,
			&i.TenantID,
			&i.Name,
			&i.Code,
			&i.DatabaseName,
			&i.Description,
			&i.Logo,
			&i.IsActive,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const toggleOrganizationStatus = `-- name: ToggleOrganizationStatus :one
UPDATE organizations
SET is_active = NOT is_active,
    updated_at = CURRENT_TIMESTAMP
WHERE org_id = $1 AND tenant_id = $2
RETURNING org_id, tenant_id, name, code, database_name, description, logo, is_active, created_by, created_at, updated_at
`

type ToggleOrganizationStatusParams struct {
	OrgID    uuid.UUID `db:"org_id" json:"org_id"`
	TenantID uuid.UUID `db:"tenant_id" json:"tenant_id"`
}

func (q *Queries) ToggleOrganizationStatus(ctx context.Context, arg ToggleOrganizationStatusParams) (*Organization, error) {
	row := q.db.QueryRow(ctx, toggleOrganizationStatus, arg.OrgID, arg.TenantID)
	var i Organization
	err := row.Scan(
		&i.OrgID,
		&i.TenantID,
		&i.Name,
		&i.Code,
		&i.DatabaseName,
		&i.Description,
		&i.Logo,
		&i.IsActive,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const updateOrganization = `-- name: UpdateOrganization :one
UPDATE organizations
SET 
    name = CASE WHEN $1::text IS NOT NULL THEN $1 ELSE name END,
    description = CASE WHEN $2::text IS NOT NULL THEN $2 ELSE description END,
    logo = CASE WHEN $3::text IS NOT NULL THEN $3 ELSE logo END,
    is_active = CASE WHEN $4::boolean IS NOT NULL THEN $4 ELSE is_active END,
    updated_at = $5
WHERE org_id = $6 AND tenant_id = $7
RETURNING org_id, tenant_id, name, code, database_name, description, logo, is_active, created_by, created_at, updated_at
`

type UpdateOrganizationParams struct {
	Name        string           `db:"name" json:"name"`
	Description string           `db:"description" json:"description"`
	Logo        string           `db:"logo" json:"logo"`
	IsActive    bool             `db:"is_active" json:"is_active"`
	UpdatedAt   pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	OrgID       uuid.UUID        `db:"org_id" json:"org_id"`
	TenantID    uuid.UUID        `db:"tenant_id" json:"tenant_id"`
}

func (q *Queries) UpdateOrganization(ctx context.Context, arg UpdateOrganizationParams) (*Organization, error) {
	row := q.db.QueryRow(ctx, updateOrganization,
		arg.Name,
		arg.Description,
		arg.Logo,
		arg.IsActive,
		arg.UpdatedAt,
		arg.OrgID,
		arg.TenantID,
	)
	var i Organization
	err := row.Scan(
		&i.OrgID,
		&i.TenantID,
		&i.Name,
		&i.Code,
		&i.DatabaseName,
		&i.Description,
		&i.Logo,
		&i.IsActive,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
