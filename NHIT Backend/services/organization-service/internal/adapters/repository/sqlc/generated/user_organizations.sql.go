// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: user_organizations.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countUserOrganizations = `-- name: CountUserOrganizations :one
SELECT COUNT(*) FROM user_organizations
WHERE user_id = $1
`

func (q *Queries) CountUserOrganizations(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countUserOrganizations, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createUserOrganization = `-- name: CreateUserOrganization :one
INSERT INTO user_organizations (
    user_id, org_id, role_id, is_current_context,
    joined_at, updated_at
) VALUES ($1, $2, $3, $4, $5, $6)
RETURNING user_id, org_id, role_id, is_current_context, joined_at, updated_at
`

type CreateUserOrganizationParams struct {
	UserID           uuid.UUID        `db:"user_id" json:"user_id"`
	OrgID            uuid.UUID        `db:"org_id" json:"org_id"`
	RoleID           uuid.UUID        `db:"role_id" json:"role_id"`
	IsCurrentContext bool             `db:"is_current_context" json:"is_current_context"`
	JoinedAt         pgtype.Timestamp `db:"joined_at" json:"joined_at"`
	UpdatedAt        pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

func (q *Queries) CreateUserOrganization(ctx context.Context, arg CreateUserOrganizationParams) (*UserOrganization, error) {
	row := q.db.QueryRow(ctx, createUserOrganization,
		arg.UserID,
		arg.OrgID,
		arg.RoleID,
		arg.IsCurrentContext,
		arg.JoinedAt,
		arg.UpdatedAt,
	)
	var i UserOrganization
	err := row.Scan(
		&i.UserID,
		&i.OrgID,
		&i.RoleID,
		&i.IsCurrentContext,
		&i.JoinedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const deleteUserOrganization = `-- name: DeleteUserOrganization :exec
DELETE FROM user_organizations
WHERE user_id = $1 AND org_id = $2
`

type DeleteUserOrganizationParams struct {
	UserID uuid.UUID `db:"user_id" json:"user_id"`
	OrgID  uuid.UUID `db:"org_id" json:"org_id"`
}

func (q *Queries) DeleteUserOrganization(ctx context.Context, arg DeleteUserOrganizationParams) error {
	_, err := q.db.Exec(ctx, deleteUserOrganization, arg.UserID, arg.OrgID)
	return err
}

const getOrganizationUsers = `-- name: GetOrganizationUsers :many
SELECT user_id, org_id, role_id, is_current_context, joined_at, updated_at FROM user_organizations
WHERE org_id = $1
ORDER BY joined_at DESC
`

func (q *Queries) GetOrganizationUsers(ctx context.Context, orgID uuid.UUID) ([]*UserOrganization, error) {
	rows, err := q.db.Query(ctx, getOrganizationUsers, orgID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*UserOrganization{}
	for rows.Next() {
		var i UserOrganization
		if err := rows.Scan(
			&i.UserID,
			&i.OrgID,
			&i.RoleID,
			&i.IsCurrentContext,
			&i.JoinedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserOrganization = `-- name: GetUserOrganization :one
SELECT user_id, org_id, role_id, is_current_context, joined_at, updated_at FROM user_organizations
WHERE user_id = $1 AND org_id = $2
`

type GetUserOrganizationParams struct {
	UserID uuid.UUID `db:"user_id" json:"user_id"`
	OrgID  uuid.UUID `db:"org_id" json:"org_id"`
}

func (q *Queries) GetUserOrganization(ctx context.Context, arg GetUserOrganizationParams) (*UserOrganization, error) {
	row := q.db.QueryRow(ctx, getUserOrganization, arg.UserID, arg.OrgID)
	var i UserOrganization
	err := row.Scan(
		&i.UserID,
		&i.OrgID,
		&i.RoleID,
		&i.IsCurrentContext,
		&i.JoinedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getUserOrganizations = `-- name: GetUserOrganizations :many
SELECT user_id, org_id, role_id, is_current_context, joined_at, updated_at FROM user_organizations
WHERE user_id = $1
ORDER BY joined_at DESC
`

func (q *Queries) GetUserOrganizations(ctx context.Context, userID uuid.UUID) ([]*UserOrganization, error) {
	rows, err := q.db.Query(ctx, getUserOrganizations, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*UserOrganization{}
	for rows.Next() {
		var i UserOrganization
		if err := rows.Scan(
			&i.UserID,
			&i.OrgID,
			&i.RoleID,
			&i.IsCurrentContext,
			&i.JoinedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setCurrentContext = `-- name: SetCurrentContext :exec
UPDATE user_organizations
SET is_current_context = CASE 
    WHEN org_id = $2 THEN true
    ELSE false
END
WHERE user_id = $1
`

type SetCurrentContextParams struct {
	UserID uuid.UUID `db:"user_id" json:"user_id"`
	OrgID  uuid.UUID `db:"org_id" json:"org_id"`
}

func (q *Queries) SetCurrentContext(ctx context.Context, arg SetCurrentContextParams) error {
	_, err := q.db.Exec(ctx, setCurrentContext, arg.UserID, arg.OrgID)
	return err
}

const updateUserOrganizationRole = `-- name: UpdateUserOrganizationRole :one
UPDATE user_organizations
SET role_id = $1,
    updated_at = CURRENT_TIMESTAMP
WHERE user_id = $2 AND org_id = $3
RETURNING user_id, org_id, role_id, is_current_context, joined_at, updated_at
`

type UpdateUserOrganizationRoleParams struct {
	RoleID uuid.UUID `db:"role_id" json:"role_id"`
	UserID uuid.UUID `db:"user_id" json:"user_id"`
	OrgID  uuid.UUID `db:"org_id" json:"org_id"`
}

func (q *Queries) UpdateUserOrganizationRole(ctx context.Context, arg UpdateUserOrganizationRoleParams) (*UserOrganization, error) {
	row := q.db.QueryRow(ctx, updateUserOrganizationRole, arg.RoleID, arg.UserID, arg.OrgID)
	var i UserOrganization
	err := row.Scan(
		&i.UserID,
		&i.OrgID,
		&i.RoleID,
		&i.IsCurrentContext,
		&i.JoinedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
