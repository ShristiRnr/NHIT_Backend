// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: users.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countAllUsers = `-- name: CountAllUsers :one
SELECT COUNT(*) FROM users
`

func (q *Queries) CountAllUsers(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countAllUsers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUsersByTenant = `-- name: CountUsersByTenant :one
SELECT COUNT(*) FROM users
WHERE tenant_id = $1
`

func (q *Queries) CountUsersByTenant(ctx context.Context, tenantID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countUsersByTenant, tenantID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
    tenant_id, name, email, password, department_id, designation_id,
    account_holder_name, bank_name, bank_account_number, ifsc_code, signature_url, is_active
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
RETURNING user_id, tenant_id, name, email, password, email_verified_at, last_login_at, last_logout_at, last_login_ip, user_agent, department_id, designation_id, created_at, updated_at, account_holder_name, bank_name, bank_account_number, ifsc_code, signature_url, is_active, deactivated_at, deactivated_by, deactivated_by_name
`

type CreateUserParams struct {
	TenantID          uuid.UUID     `db:"tenant_id" json:"tenant_id"`
	Name              string        `db:"name" json:"name"`
	Email             string        `db:"email" json:"email"`
	Password          string        `db:"password" json:"password"`
	DepartmentID      uuid.NullUUID `db:"department_id" json:"department_id"`
	DesignationID     uuid.NullUUID `db:"designation_id" json:"designation_id"`
	AccountHolderName *string       `db:"account_holder_name" json:"account_holder_name"`
	BankName          *string       `db:"bank_name" json:"bank_name"`
	BankAccountNumber *string       `db:"bank_account_number" json:"bank_account_number"`
	IfscCode          *string       `db:"ifsc_code" json:"ifsc_code"`
	SignatureUrl      *string       `db:"signature_url" json:"signature_url"`
	IsActive          bool          `db:"is_active" json:"is_active"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (*User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.TenantID,
		arg.Name,
		arg.Email,
		arg.Password,
		arg.DepartmentID,
		arg.DesignationID,
		arg.AccountHolderName,
		arg.BankName,
		arg.BankAccountNumber,
		arg.IfscCode,
		arg.SignatureUrl,
		arg.IsActive,
	)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.TenantID,
		&i.Name,
		&i.Email,
		&i.Password,
		&i.EmailVerifiedAt,
		&i.LastLoginAt,
		&i.LastLogoutAt,
		&i.LastLoginIp,
		&i.UserAgent,
		&i.DepartmentID,
		&i.DesignationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AccountHolderName,
		&i.BankName,
		&i.BankAccountNumber,
		&i.IfscCode,
		&i.SignatureUrl,
		&i.IsActive,
		&i.DeactivatedAt,
		&i.DeactivatedBy,
		&i.DeactivatedByName,
	)
	return &i, err
}

const createUserWithVerification = `-- name: CreateUserWithVerification :one
INSERT INTO users (
    tenant_id, name, email, password, email_verified_at, department_id, designation_id,
    account_holder_name, bank_name, bank_account_number, ifsc_code, signature_url, is_active
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
RETURNING user_id, tenant_id, name, email, password, email_verified_at, last_login_at, last_logout_at, last_login_ip, user_agent, department_id, designation_id, created_at, updated_at, account_holder_name, bank_name, bank_account_number, ifsc_code, signature_url, is_active, deactivated_at, deactivated_by, deactivated_by_name
`

type CreateUserWithVerificationParams struct {
	TenantID          uuid.UUID          `db:"tenant_id" json:"tenant_id"`
	Name              string             `db:"name" json:"name"`
	Email             string             `db:"email" json:"email"`
	Password          string             `db:"password" json:"password"`
	EmailVerifiedAt   pgtype.Timestamptz `db:"email_verified_at" json:"email_verified_at"`
	DepartmentID      uuid.NullUUID      `db:"department_id" json:"department_id"`
	DesignationID     uuid.NullUUID      `db:"designation_id" json:"designation_id"`
	AccountHolderName *string            `db:"account_holder_name" json:"account_holder_name"`
	BankName          *string            `db:"bank_name" json:"bank_name"`
	BankAccountNumber *string            `db:"bank_account_number" json:"bank_account_number"`
	IfscCode          *string            `db:"ifsc_code" json:"ifsc_code"`
	SignatureUrl      *string            `db:"signature_url" json:"signature_url"`
	IsActive          bool               `db:"is_active" json:"is_active"`
}

func (q *Queries) CreateUserWithVerification(ctx context.Context, arg CreateUserWithVerificationParams) (*User, error) {
	row := q.db.QueryRow(ctx, createUserWithVerification,
		arg.TenantID,
		arg.Name,
		arg.Email,
		arg.Password,
		arg.EmailVerifiedAt,
		arg.DepartmentID,
		arg.DesignationID,
		arg.AccountHolderName,
		arg.BankName,
		arg.BankAccountNumber,
		arg.IfscCode,
		arg.SignatureUrl,
		arg.IsActive,
	)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.TenantID,
		&i.Name,
		&i.Email,
		&i.Password,
		&i.EmailVerifiedAt,
		&i.LastLoginAt,
		&i.LastLogoutAt,
		&i.LastLoginIp,
		&i.UserAgent,
		&i.DepartmentID,
		&i.DesignationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AccountHolderName,
		&i.BankName,
		&i.BankAccountNumber,
		&i.IfscCode,
		&i.SignatureUrl,
		&i.IsActive,
		&i.DeactivatedAt,
		&i.DeactivatedBy,
		&i.DeactivatedByName,
	)
	return &i, err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users
WHERE user_id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteUser, userID)
	return err
}

const getUser = `-- name: GetUser :one
SELECT user_id, tenant_id, name, email, password, email_verified_at, last_login_at, last_logout_at, last_login_ip, user_agent, department_id, designation_id, created_at, updated_at, account_holder_name, bank_name, bank_account_number, ifsc_code, signature_url, is_active, deactivated_at, deactivated_by, deactivated_by_name FROM users
WHERE user_id = $1
`

func (q *Queries) GetUser(ctx context.Context, userID uuid.UUID) (*User, error) {
	row := q.db.QueryRow(ctx, getUser, userID)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.TenantID,
		&i.Name,
		&i.Email,
		&i.Password,
		&i.EmailVerifiedAt,
		&i.LastLoginAt,
		&i.LastLogoutAt,
		&i.LastLoginIp,
		&i.UserAgent,
		&i.DepartmentID,
		&i.DesignationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AccountHolderName,
		&i.BankName,
		&i.BankAccountNumber,
		&i.IfscCode,
		&i.SignatureUrl,
		&i.IsActive,
		&i.DeactivatedAt,
		&i.DeactivatedBy,
		&i.DeactivatedByName,
	)
	return &i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT user_id, tenant_id, name, email, password, email_verified_at, last_login_at, last_logout_at, last_login_ip, user_agent, department_id, designation_id, created_at, updated_at, account_holder_name, bank_name, bank_account_number, ifsc_code, signature_url, is_active, deactivated_at, deactivated_by, deactivated_by_name FROM users
WHERE email = $1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (*User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.TenantID,
		&i.Name,
		&i.Email,
		&i.Password,
		&i.EmailVerifiedAt,
		&i.LastLoginAt,
		&i.LastLogoutAt,
		&i.LastLoginIp,
		&i.UserAgent,
		&i.DepartmentID,
		&i.DesignationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AccountHolderName,
		&i.BankName,
		&i.BankAccountNumber,
		&i.IfscCode,
		&i.SignatureUrl,
		&i.IsActive,
		&i.DeactivatedAt,
		&i.DeactivatedBy,
		&i.DeactivatedByName,
	)
	return &i, err
}

const getUserByEmailAndTenant = `-- name: GetUserByEmailAndTenant :one
SELECT user_id, tenant_id, name, email, password, email_verified_at, last_login_at, last_logout_at, last_login_ip, user_agent, department_id, designation_id, created_at, updated_at, account_holder_name, bank_name, bank_account_number, ifsc_code, signature_url, is_active, deactivated_at, deactivated_by, deactivated_by_name FROM users
WHERE tenant_id = $1 AND email = $2
`

type GetUserByEmailAndTenantParams struct {
	TenantID uuid.UUID `db:"tenant_id" json:"tenant_id"`
	Email    string    `db:"email" json:"email"`
}

func (q *Queries) GetUserByEmailAndTenant(ctx context.Context, arg GetUserByEmailAndTenantParams) (*User, error) {
	row := q.db.QueryRow(ctx, getUserByEmailAndTenant, arg.TenantID, arg.Email)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.TenantID,
		&i.Name,
		&i.Email,
		&i.Password,
		&i.EmailVerifiedAt,
		&i.LastLoginAt,
		&i.LastLogoutAt,
		&i.LastLoginIp,
		&i.UserAgent,
		&i.DepartmentID,
		&i.DesignationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AccountHolderName,
		&i.BankName,
		&i.BankAccountNumber,
		&i.IfscCode,
		&i.SignatureUrl,
		&i.IsActive,
		&i.DeactivatedAt,
		&i.DeactivatedBy,
		&i.DeactivatedByName,
	)
	return &i, err
}

const listAllUsers = `-- name: ListAllUsers :many
SELECT user_id, tenant_id, name, email, password, email_verified_at, last_login_at, last_logout_at, last_login_ip, user_agent, department_id, designation_id, created_at, updated_at, account_holder_name, bank_name, bank_account_number, ifsc_code, signature_url, is_active, deactivated_at, deactivated_by, deactivated_by_name FROM users
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListAllUsersParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

func (q *Queries) ListAllUsers(ctx context.Context, arg ListAllUsersParams) ([]*User, error) {
	rows, err := q.db.Query(ctx, listAllUsers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UserID,
			&i.TenantID,
			&i.Name,
			&i.Email,
			&i.Password,
			&i.EmailVerifiedAt,
			&i.LastLoginAt,
			&i.LastLogoutAt,
			&i.LastLoginIp,
			&i.UserAgent,
			&i.DepartmentID,
			&i.DesignationID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AccountHolderName,
			&i.BankName,
			&i.BankAccountNumber,
			&i.IfscCode,
			&i.SignatureUrl,
			&i.IsActive,
			&i.DeactivatedAt,
			&i.DeactivatedBy,
			&i.DeactivatedByName,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersByDepartment = `-- name: ListUsersByDepartment :many
SELECT user_id, tenant_id, name, email, password, email_verified_at, last_login_at, last_logout_at, last_login_ip, user_agent, department_id, designation_id, created_at, updated_at, account_holder_name, bank_name, bank_account_number, ifsc_code, signature_url, is_active, deactivated_at, deactivated_by, deactivated_by_name FROM users
WHERE department_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListUsersByDepartmentParams struct {
	DepartmentID uuid.NullUUID `db:"department_id" json:"department_id"`
	Limit        int32         `db:"limit" json:"limit"`
	Offset       int32         `db:"offset" json:"offset"`
}

func (q *Queries) ListUsersByDepartment(ctx context.Context, arg ListUsersByDepartmentParams) ([]*User, error) {
	rows, err := q.db.Query(ctx, listUsersByDepartment, arg.DepartmentID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UserID,
			&i.TenantID,
			&i.Name,
			&i.Email,
			&i.Password,
			&i.EmailVerifiedAt,
			&i.LastLoginAt,
			&i.LastLogoutAt,
			&i.LastLoginIp,
			&i.UserAgent,
			&i.DepartmentID,
			&i.DesignationID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AccountHolderName,
			&i.BankName,
			&i.BankAccountNumber,
			&i.IfscCode,
			&i.SignatureUrl,
			&i.IsActive,
			&i.DeactivatedAt,
			&i.DeactivatedBy,
			&i.DeactivatedByName,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersByDesignation = `-- name: ListUsersByDesignation :many
SELECT user_id, tenant_id, name, email, password, email_verified_at, last_login_at, last_logout_at, last_login_ip, user_agent, department_id, designation_id, created_at, updated_at, account_holder_name, bank_name, bank_account_number, ifsc_code, signature_url, is_active, deactivated_at, deactivated_by, deactivated_by_name FROM users
WHERE designation_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListUsersByDesignationParams struct {
	DesignationID uuid.NullUUID `db:"designation_id" json:"designation_id"`
	Limit         int32         `db:"limit" json:"limit"`
	Offset        int32         `db:"offset" json:"offset"`
}

func (q *Queries) ListUsersByDesignation(ctx context.Context, arg ListUsersByDesignationParams) ([]*User, error) {
	rows, err := q.db.Query(ctx, listUsersByDesignation, arg.DesignationID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UserID,
			&i.TenantID,
			&i.Name,
			&i.Email,
			&i.Password,
			&i.EmailVerifiedAt,
			&i.LastLoginAt,
			&i.LastLogoutAt,
			&i.LastLoginIp,
			&i.UserAgent,
			&i.DepartmentID,
			&i.DesignationID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AccountHolderName,
			&i.BankName,
			&i.BankAccountNumber,
			&i.IfscCode,
			&i.SignatureUrl,
			&i.IsActive,
			&i.DeactivatedAt,
			&i.DeactivatedBy,
			&i.DeactivatedByName,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersByTenant = `-- name: ListUsersByTenant :many
SELECT user_id, tenant_id, name, email, password, email_verified_at, last_login_at, last_logout_at, last_login_ip, user_agent, department_id, designation_id, created_at, updated_at, account_holder_name, bank_name, bank_account_number, ifsc_code, signature_url, is_active, deactivated_at, deactivated_by, deactivated_by_name FROM users
WHERE tenant_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListUsersByTenantParams struct {
	TenantID uuid.UUID `db:"tenant_id" json:"tenant_id"`
	Limit    int32     `db:"limit" json:"limit"`
	Offset   int32     `db:"offset" json:"offset"`
}

func (q *Queries) ListUsersByTenant(ctx context.Context, arg ListUsersByTenantParams) ([]*User, error) {
	rows, err := q.db.Query(ctx, listUsersByTenant, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UserID,
			&i.TenantID,
			&i.Name,
			&i.Email,
			&i.Password,
			&i.EmailVerifiedAt,
			&i.LastLoginAt,
			&i.LastLogoutAt,
			&i.LastLoginIp,
			&i.UserAgent,
			&i.DepartmentID,
			&i.DesignationID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AccountHolderName,
			&i.BankName,
			&i.BankAccountNumber,
			&i.IfscCode,
			&i.SignatureUrl,
			&i.IsActive,
			&i.DeactivatedAt,
			&i.DeactivatedBy,
			&i.DeactivatedByName,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchUsersByEmail = `-- name: SearchUsersByEmail :many
SELECT user_id, tenant_id, name, email, password, email_verified_at, last_login_at, last_logout_at, last_login_ip, user_agent, department_id, designation_id, created_at, updated_at, account_holder_name, bank_name, bank_account_number, ifsc_code, signature_url, is_active, deactivated_at, deactivated_by, deactivated_by_name FROM users
WHERE LOWER(email) LIKE LOWER('%' || $1 || '%')
ORDER BY email ASC
LIMIT $2 OFFSET $3
`

type SearchUsersByEmailParams struct {
	Column1 *string `db:"column_1" json:"column_1"`
	Limit   int32   `db:"limit" json:"limit"`
	Offset  int32   `db:"offset" json:"offset"`
}

func (q *Queries) SearchUsersByEmail(ctx context.Context, arg SearchUsersByEmailParams) ([]*User, error) {
	rows, err := q.db.Query(ctx, searchUsersByEmail, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UserID,
			&i.TenantID,
			&i.Name,
			&i.Email,
			&i.Password,
			&i.EmailVerifiedAt,
			&i.LastLoginAt,
			&i.LastLogoutAt,
			&i.LastLoginIp,
			&i.UserAgent,
			&i.DepartmentID,
			&i.DesignationID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AccountHolderName,
			&i.BankName,
			&i.BankAccountNumber,
			&i.IfscCode,
			&i.SignatureUrl,
			&i.IsActive,
			&i.DeactivatedAt,
			&i.DeactivatedBy,
			&i.DeactivatedByName,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchUsersByName = `-- name: SearchUsersByName :many
SELECT user_id, tenant_id, name, email, password, email_verified_at, last_login_at, last_logout_at, last_login_ip, user_agent, department_id, designation_id, created_at, updated_at, account_holder_name, bank_name, bank_account_number, ifsc_code, signature_url, is_active, deactivated_at, deactivated_by, deactivated_by_name FROM users
WHERE LOWER(name) LIKE LOWER('%' || $1 || '%')
ORDER BY name ASC
LIMIT $2 OFFSET $3
`

type SearchUsersByNameParams struct {
	Column1 *string `db:"column_1" json:"column_1"`
	Limit   int32   `db:"limit" json:"limit"`
	Offset  int32   `db:"offset" json:"offset"`
}

func (q *Queries) SearchUsersByName(ctx context.Context, arg SearchUsersByNameParams) ([]*User, error) {
	rows, err := q.db.Query(ctx, searchUsersByName, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UserID,
			&i.TenantID,
			&i.Name,
			&i.Email,
			&i.Password,
			&i.EmailVerifiedAt,
			&i.LastLoginAt,
			&i.LastLogoutAt,
			&i.LastLoginIp,
			&i.UserAgent,
			&i.DepartmentID,
			&i.DesignationID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AccountHolderName,
			&i.BankName,
			&i.BankAccountNumber,
			&i.IfscCode,
			&i.SignatureUrl,
			&i.IsActive,
			&i.DeactivatedAt,
			&i.DeactivatedBy,
			&i.DeactivatedByName,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUser = `-- name: UpdateUser :one
UPDATE users
SET 
    name = $2, 
    email = $3, 
    password = $4, 
    department_id = $5,
    designation_id = $6,
    account_holder_name = $7,
    bank_name = $8,
    bank_account_number = $9,
    ifsc_code = $10,
    signature_url = $11,
    is_active = $12,
    deactivated_at = $13,
    deactivated_by = $14,
    deactivated_by_name = $15,
    updated_at = NOW()
WHERE user_id = $1
RETURNING user_id, tenant_id, name, email, password, email_verified_at, last_login_at, last_logout_at, last_login_ip, user_agent, department_id, designation_id, created_at, updated_at, account_holder_name, bank_name, bank_account_number, ifsc_code, signature_url, is_active, deactivated_at, deactivated_by, deactivated_by_name
`

type UpdateUserParams struct {
	UserID            uuid.UUID          `db:"user_id" json:"user_id"`
	Name              string             `db:"name" json:"name"`
	Email             string             `db:"email" json:"email"`
	Password          string             `db:"password" json:"password"`
	DepartmentID      uuid.NullUUID      `db:"department_id" json:"department_id"`
	DesignationID     uuid.NullUUID      `db:"designation_id" json:"designation_id"`
	AccountHolderName *string            `db:"account_holder_name" json:"account_holder_name"`
	BankName          *string            `db:"bank_name" json:"bank_name"`
	BankAccountNumber *string            `db:"bank_account_number" json:"bank_account_number"`
	IfscCode          *string            `db:"ifsc_code" json:"ifsc_code"`
	SignatureUrl      *string            `db:"signature_url" json:"signature_url"`
	IsActive          bool               `db:"is_active" json:"is_active"`
	DeactivatedAt     pgtype.Timestamptz `db:"deactivated_at" json:"deactivated_at"`
	DeactivatedBy     pgtype.UUID        `db:"deactivated_by" json:"deactivated_by"`
	DeactivatedByName *string            `db:"deactivated_by_name" json:"deactivated_by_name"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (*User, error) {
	row := q.db.QueryRow(ctx, updateUser,
		arg.UserID,
		arg.Name,
		arg.Email,
		arg.Password,
		arg.DepartmentID,
		arg.DesignationID,
		arg.AccountHolderName,
		arg.BankName,
		arg.BankAccountNumber,
		arg.IfscCode,
		arg.SignatureUrl,
		arg.IsActive,
		arg.DeactivatedAt,
		arg.DeactivatedBy,
		arg.DeactivatedByName,
	)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.TenantID,
		&i.Name,
		&i.Email,
		&i.Password,
		&i.EmailVerifiedAt,
		&i.LastLoginAt,
		&i.LastLogoutAt,
		&i.LastLoginIp,
		&i.UserAgent,
		&i.DepartmentID,
		&i.DesignationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AccountHolderName,
		&i.BankName,
		&i.BankAccountNumber,
		&i.IfscCode,
		&i.SignatureUrl,
		&i.IsActive,
		&i.DeactivatedAt,
		&i.DeactivatedBy,
		&i.DeactivatedByName,
	)
	return &i, err
}

const updateUserDepartment = `-- name: UpdateUserDepartment :one
UPDATE users
SET department_id = $2, updated_at = NOW()
WHERE user_id = $1
RETURNING user_id, tenant_id, name, email, password, email_verified_at, last_login_at, last_logout_at, last_login_ip, user_agent, department_id, designation_id, created_at, updated_at, account_holder_name, bank_name, bank_account_number, ifsc_code, signature_url, is_active, deactivated_at, deactivated_by, deactivated_by_name
`

type UpdateUserDepartmentParams struct {
	UserID       uuid.UUID     `db:"user_id" json:"user_id"`
	DepartmentID uuid.NullUUID `db:"department_id" json:"department_id"`
}

func (q *Queries) UpdateUserDepartment(ctx context.Context, arg UpdateUserDepartmentParams) (*User, error) {
	row := q.db.QueryRow(ctx, updateUserDepartment, arg.UserID, arg.DepartmentID)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.TenantID,
		&i.Name,
		&i.Email,
		&i.Password,
		&i.EmailVerifiedAt,
		&i.LastLoginAt,
		&i.LastLogoutAt,
		&i.LastLoginIp,
		&i.UserAgent,
		&i.DepartmentID,
		&i.DesignationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AccountHolderName,
		&i.BankName,
		&i.BankAccountNumber,
		&i.IfscCode,
		&i.SignatureUrl,
		&i.IsActive,
		&i.DeactivatedAt,
		&i.DeactivatedBy,
		&i.DeactivatedByName,
	)
	return &i, err
}

const updateUserDesignation = `-- name: UpdateUserDesignation :one
UPDATE users
SET designation_id = $2, updated_at = NOW()
WHERE user_id = $1
RETURNING user_id, tenant_id, name, email, password, email_verified_at, last_login_at, last_logout_at, last_login_ip, user_agent, department_id, designation_id, created_at, updated_at, account_holder_name, bank_name, bank_account_number, ifsc_code, signature_url, is_active, deactivated_at, deactivated_by, deactivated_by_name
`

type UpdateUserDesignationParams struct {
	UserID        uuid.UUID     `db:"user_id" json:"user_id"`
	DesignationID uuid.NullUUID `db:"designation_id" json:"designation_id"`
}

func (q *Queries) UpdateUserDesignation(ctx context.Context, arg UpdateUserDesignationParams) (*User, error) {
	row := q.db.QueryRow(ctx, updateUserDesignation, arg.UserID, arg.DesignationID)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.TenantID,
		&i.Name,
		&i.Email,
		&i.Password,
		&i.EmailVerifiedAt,
		&i.LastLoginAt,
		&i.LastLogoutAt,
		&i.LastLoginIp,
		&i.UserAgent,
		&i.DepartmentID,
		&i.DesignationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AccountHolderName,
		&i.BankName,
		&i.BankAccountNumber,
		&i.IfscCode,
		&i.SignatureUrl,
		&i.IsActive,
		&i.DeactivatedAt,
		&i.DeactivatedBy,
		&i.DeactivatedByName,
	)
	return &i, err
}

const updateUserEmailVerification = `-- name: UpdateUserEmailVerification :one
UPDATE users
SET email_verified_at = $2, updated_at = NOW()
WHERE user_id = $1
RETURNING user_id, tenant_id, name, email, password, email_verified_at, last_login_at, last_logout_at, last_login_ip, user_agent, department_id, designation_id, created_at, updated_at, account_holder_name, bank_name, bank_account_number, ifsc_code, signature_url, is_active, deactivated_at, deactivated_by, deactivated_by_name
`

type UpdateUserEmailVerificationParams struct {
	UserID          uuid.UUID          `db:"user_id" json:"user_id"`
	EmailVerifiedAt pgtype.Timestamptz `db:"email_verified_at" json:"email_verified_at"`
}

func (q *Queries) UpdateUserEmailVerification(ctx context.Context, arg UpdateUserEmailVerificationParams) (*User, error) {
	row := q.db.QueryRow(ctx, updateUserEmailVerification, arg.UserID, arg.EmailVerifiedAt)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.TenantID,
		&i.Name,
		&i.Email,
		&i.Password,
		&i.EmailVerifiedAt,
		&i.LastLoginAt,
		&i.LastLogoutAt,
		&i.LastLoginIp,
		&i.UserAgent,
		&i.DepartmentID,
		&i.DesignationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AccountHolderName,
		&i.BankName,
		&i.BankAccountNumber,
		&i.IfscCode,
		&i.SignatureUrl,
		&i.IsActive,
		&i.DeactivatedAt,
		&i.DeactivatedBy,
		&i.DeactivatedByName,
	)
	return &i, err
}

const updateUserLastLogin = `-- name: UpdateUserLastLogin :one
UPDATE users
SET last_login_at = $2, last_login_ip = $3, user_agent = $4, updated_at = NOW()
WHERE user_id = $1
RETURNING user_id, tenant_id, name, email, password, email_verified_at, last_login_at, last_logout_at, last_login_ip, user_agent, department_id, designation_id, created_at, updated_at, account_holder_name, bank_name, bank_account_number, ifsc_code, signature_url, is_active, deactivated_at, deactivated_by, deactivated_by_name
`

type UpdateUserLastLoginParams struct {
	UserID      uuid.UUID          `db:"user_id" json:"user_id"`
	LastLoginAt pgtype.Timestamptz `db:"last_login_at" json:"last_login_at"`
	LastLoginIp *string            `db:"last_login_ip" json:"last_login_ip"`
	UserAgent   *string            `db:"user_agent" json:"user_agent"`
}

func (q *Queries) UpdateUserLastLogin(ctx context.Context, arg UpdateUserLastLoginParams) (*User, error) {
	row := q.db.QueryRow(ctx, updateUserLastLogin,
		arg.UserID,
		arg.LastLoginAt,
		arg.LastLoginIp,
		arg.UserAgent,
	)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.TenantID,
		&i.Name,
		&i.Email,
		&i.Password,
		&i.EmailVerifiedAt,
		&i.LastLoginAt,
		&i.LastLogoutAt,
		&i.LastLoginIp,
		&i.UserAgent,
		&i.DepartmentID,
		&i.DesignationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AccountHolderName,
		&i.BankName,
		&i.BankAccountNumber,
		&i.IfscCode,
		&i.SignatureUrl,
		&i.IsActive,
		&i.DeactivatedAt,
		&i.DeactivatedBy,
		&i.DeactivatedByName,
	)
	return &i, err
}

const updateUserLastLogout = `-- name: UpdateUserLastLogout :one
UPDATE users
SET last_logout_at = $2, updated_at = NOW()
WHERE user_id = $1
RETURNING user_id, tenant_id, name, email, password, email_verified_at, last_login_at, last_logout_at, last_login_ip, user_agent, department_id, designation_id, created_at, updated_at, account_holder_name, bank_name, bank_account_number, ifsc_code, signature_url, is_active, deactivated_at, deactivated_by, deactivated_by_name
`

type UpdateUserLastLogoutParams struct {
	UserID       uuid.UUID          `db:"user_id" json:"user_id"`
	LastLogoutAt pgtype.Timestamptz `db:"last_logout_at" json:"last_logout_at"`
}

func (q *Queries) UpdateUserLastLogout(ctx context.Context, arg UpdateUserLastLogoutParams) (*User, error) {
	row := q.db.QueryRow(ctx, updateUserLastLogout, arg.UserID, arg.LastLogoutAt)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.TenantID,
		&i.Name,
		&i.Email,
		&i.Password,
		&i.EmailVerifiedAt,
		&i.LastLoginAt,
		&i.LastLogoutAt,
		&i.LastLoginIp,
		&i.UserAgent,
		&i.DepartmentID,
		&i.DesignationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AccountHolderName,
		&i.BankName,
		&i.BankAccountNumber,
		&i.IfscCode,
		&i.SignatureUrl,
		&i.IsActive,
		&i.DeactivatedAt,
		&i.DeactivatedBy,
		&i.DeactivatedByName,
	)
	return &i, err
}

const updateUserPassword = `-- name: UpdateUserPassword :one
UPDATE users
SET password = $2, updated_at = NOW()
WHERE user_id = $1
RETURNING user_id, tenant_id, name, email, password, email_verified_at, last_login_at, last_logout_at, last_login_ip, user_agent, department_id, designation_id, created_at, updated_at, account_holder_name, bank_name, bank_account_number, ifsc_code, signature_url, is_active, deactivated_at, deactivated_by, deactivated_by_name
`

type UpdateUserPasswordParams struct {
	UserID   uuid.UUID `db:"user_id" json:"user_id"`
	Password string    `db:"password" json:"password"`
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) (*User, error) {
	row := q.db.QueryRow(ctx, updateUserPassword, arg.UserID, arg.Password)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.TenantID,
		&i.Name,
		&i.Email,
		&i.Password,
		&i.EmailVerifiedAt,
		&i.LastLoginAt,
		&i.LastLogoutAt,
		&i.LastLoginIp,
		&i.UserAgent,
		&i.DepartmentID,
		&i.DesignationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AccountHolderName,
		&i.BankName,
		&i.BankAccountNumber,
		&i.IfscCode,
		&i.SignatureUrl,
		&i.IsActive,
		&i.DeactivatedAt,
		&i.DeactivatedBy,
		&i.DeactivatedByName,
	)
	return &i, err
}

const updateUserProfile = `-- name: UpdateUserProfile :one
UPDATE users
SET name = $2, email = $3, updated_at = NOW()
WHERE user_id = $1
RETURNING user_id, tenant_id, name, email, password, email_verified_at, last_login_at, last_logout_at, last_login_ip, user_agent, department_id, designation_id, created_at, updated_at, account_holder_name, bank_name, bank_account_number, ifsc_code, signature_url, is_active, deactivated_at, deactivated_by, deactivated_by_name
`

type UpdateUserProfileParams struct {
	UserID uuid.UUID `db:"user_id" json:"user_id"`
	Name   string    `db:"name" json:"name"`
	Email  string    `db:"email" json:"email"`
}

func (q *Queries) UpdateUserProfile(ctx context.Context, arg UpdateUserProfileParams) (*User, error) {
	row := q.db.QueryRow(ctx, updateUserProfile, arg.UserID, arg.Name, arg.Email)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.TenantID,
		&i.Name,
		&i.Email,
		&i.Password,
		&i.EmailVerifiedAt,
		&i.LastLoginAt,
		&i.LastLogoutAt,
		&i.LastLoginIp,
		&i.UserAgent,
		&i.DepartmentID,
		&i.DesignationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AccountHolderName,
		&i.BankName,
		&i.BankAccountNumber,
		&i.IfscCode,
		&i.SignatureUrl,
		&i.IsActive,
		&i.DeactivatedAt,
		&i.DeactivatedBy,
		&i.DeactivatedByName,
	)
	return &i, err
}

const userExistsByEmail = `-- name: UserExistsByEmail :one
SELECT EXISTS(SELECT 1 FROM users WHERE email = $1) AS exists
`

func (q *Queries) UserExistsByEmail(ctx context.Context, email string) (bool, error) {
	row := q.db.QueryRow(ctx, userExistsByEmail, email)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const userExistsByID = `-- name: UserExistsByID :one
SELECT EXISTS(SELECT 1 FROM users WHERE user_id = $1) AS exists
`

func (q *Queries) UserExistsByID(ctx context.Context, userID uuid.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, userExistsByID, userID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
