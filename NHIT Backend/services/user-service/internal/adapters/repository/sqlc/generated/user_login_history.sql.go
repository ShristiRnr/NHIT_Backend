// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: user_login_history.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countUserLoginHistories = `-- name: CountUserLoginHistories :one
SELECT COUNT(*) FROM user_login_history
WHERE user_id = $1
`

func (q *Queries) CountUserLoginHistories(ctx context.Context, userID uuid.NullUUID) (int64, error) {
	row := q.db.QueryRow(ctx, countUserLoginHistories, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createLoginHistory = `-- name: CreateLoginHistory :one
INSERT INTO user_login_history (user_id, ip_address, user_agent, login_time)
VALUES ($1, $2, $3, $4)
RETURNING history_id, user_id, ip_address, user_agent, login_time
`

type CreateLoginHistoryParams struct {
	UserID    uuid.NullUUID      `db:"user_id" json:"user_id"`
	IpAddress *string            `db:"ip_address" json:"ip_address"`
	UserAgent *string            `db:"user_agent" json:"user_agent"`
	LoginTime pgtype.Timestamptz `db:"login_time" json:"login_time"`
}

func (q *Queries) CreateLoginHistory(ctx context.Context, arg CreateLoginHistoryParams) (*UserLoginHistory, error) {
	row := q.db.QueryRow(ctx, createLoginHistory,
		arg.UserID,
		arg.IpAddress,
		arg.UserAgent,
		arg.LoginTime,
	)
	var i UserLoginHistory
	err := row.Scan(
		&i.HistoryID,
		&i.UserID,
		&i.IpAddress,
		&i.UserAgent,
		&i.LoginTime,
	)
	return &i, err
}

const deleteLoginHistory = `-- name: DeleteLoginHistory :exec
DELETE FROM user_login_history
WHERE history_id = $1
`

func (q *Queries) DeleteLoginHistory(ctx context.Context, historyID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteLoginHistory, historyID)
	return err
}

const deleteOldLoginHistories = `-- name: DeleteOldLoginHistories :exec
DELETE FROM user_login_history
WHERE login_time < $1
`

func (q *Queries) DeleteOldLoginHistories(ctx context.Context, loginTime pgtype.Timestamptz) error {
	_, err := q.db.Exec(ctx, deleteOldLoginHistories, loginTime)
	return err
}

const deleteUserLoginHistories = `-- name: DeleteUserLoginHistories :exec
DELETE FROM user_login_history
WHERE user_id = $1
`

func (q *Queries) DeleteUserLoginHistories(ctx context.Context, userID uuid.NullUUID) error {
	_, err := q.db.Exec(ctx, deleteUserLoginHistories, userID)
	return err
}

const getLoginHistory = `-- name: GetLoginHistory :one
SELECT history_id, user_id, ip_address, user_agent, login_time FROM user_login_history
WHERE history_id = $1
`

func (q *Queries) GetLoginHistory(ctx context.Context, historyID uuid.UUID) (*UserLoginHistory, error) {
	row := q.db.QueryRow(ctx, getLoginHistory, historyID)
	var i UserLoginHistory
	err := row.Scan(
		&i.HistoryID,
		&i.UserID,
		&i.IpAddress,
		&i.UserAgent,
		&i.LoginTime,
	)
	return &i, err
}

const listRecentLoginHistories = `-- name: ListRecentLoginHistories :many
SELECT history_id, user_id, ip_address, user_agent, login_time FROM user_login_history
WHERE user_id = $1
ORDER BY login_time DESC
LIMIT $2
`

type ListRecentLoginHistoriesParams struct {
	UserID uuid.NullUUID `db:"user_id" json:"user_id"`
	Limit  int32         `db:"limit" json:"limit"`
}

func (q *Queries) ListRecentLoginHistories(ctx context.Context, arg ListRecentLoginHistoriesParams) ([]*UserLoginHistory, error) {
	rows, err := q.db.Query(ctx, listRecentLoginHistories, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*UserLoginHistory{}
	for rows.Next() {
		var i UserLoginHistory
		if err := rows.Scan(
			&i.HistoryID,
			&i.UserID,
			&i.IpAddress,
			&i.UserAgent,
			&i.LoginTime,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserLoginHistories = `-- name: ListUserLoginHistories :many
SELECT history_id, user_id, ip_address, user_agent, login_time FROM user_login_history
WHERE user_id = $1
ORDER BY login_time DESC
LIMIT $2 OFFSET $3
`

type ListUserLoginHistoriesParams struct {
	UserID uuid.NullUUID `db:"user_id" json:"user_id"`
	Limit  int32         `db:"limit" json:"limit"`
	Offset int32         `db:"offset" json:"offset"`
}

func (q *Queries) ListUserLoginHistories(ctx context.Context, arg ListUserLoginHistoriesParams) ([]*UserLoginHistory, error) {
	rows, err := q.db.Query(ctx, listUserLoginHistories, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*UserLoginHistory{}
	for rows.Next() {
		var i UserLoginHistory
		if err := rows.Scan(
			&i.HistoryID,
			&i.UserID,
			&i.IpAddress,
			&i.UserAgent,
			&i.LoginTime,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
